\documentclass[12pt,fleqn,a4paper]{book}
% 
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
%
% Common customization:
%
\pagestyle{headings}
\newtheorem{theorem}{Теорема}[chapter]
\newtheorem{lemma}{Лемма}[chapter]
\newtheorem{corollary}{Следствие}[chapter]
\newtheorem{proposition}{Утверждение}[chapter]
\newtheorem{fact}{Факт}[chapter]
\theoremstyle{definition}
\newtheorem{problem}{Задача}[chapter]
\newtheorem{exercise}{Упражнение}[chapter]
\newtheorem{example}{Пример}[chapter]
\newtheorem{definition}{Определение}[chapter]
\newtheorem{remark}{Замечание}[chapter]
\newtheorem{algorithm}{Алгоритм}[chapter]
\def\gap{\medskip\centerline{\fbox{\Huge\bfseries{ПРОБЕЛ В КОНСПЕКТЕ.}}}\medskip}
\advance\headheight by 7pt
\def\headsep{15mm}
\newcommand{\lecture}[3]{%
\def\rightmark{\fbox{\parbox{125mm}{\lecturername: \coursetitle%
\hfil\phantom{.}}}}
\def\leftmark{\fbox{\parbox{125mm}{Лекция {#1}. {#2}%
\hfil\phantom{.}}}}
\renewcommand\chaptername{Лекция}\renewcommand\thechapter{#1}\chapter{{#2}\\{\small (Конспект: {#3})}}
\thispagestyle{headings}}
%
% Things to customize for the course are here:
%
\newcommand\lecturername{Э. А. Гирш}
\newcommand\coursetitle{``Информатика'' (отд. математики, 1 курс)}
%
\newcommand{\Retc}{и\;т.\;д.}
\newcommand{\poly}{\mathrm{poly}}
%
\newcommand{\ournote}[1]{\ref{?}\footnote{#1}}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\newcommand{\step}{\mathop{\longrightarrow}\limits}
%
% The document
%
\begin{document}
\selectlanguage{russian}
%
% Lecture title
%
\lecture{11}{Теория~формальных~языков~(III)}{В. Вялов}
%
\section{Бесконтекстные языки}

\subsection{Нормальные формы бесконтекстных языков}

\begin{definition}
Будем говорить, что грамматика --- в
\emph{нормальной форме Хомского} (\emph{НФХ}),
если она содержит только
правила одного из следующих типов.
\begin{enumerate}
\item $A\to BC$.
\item $A\to a$.
\item $S\to \epsilon$.
\end{enumerate}
Причем
\begin{enumerate}
\item[4.] Cтартовый символ $S$ в правых частях не встречается
(т.е. $B,C\neq S$ в пункте~1).
\end{enumerate}
\end{definition}

\begin{theorem}
Для любой бесконтекстной грамматики $G$ существует грамматика $G^*$
в НФХ, такая, что $L(G)=L(G^*)$.
\end{theorem}
\begin{proof}
1. Добавим новый стартовый символ $S^*$ и правило $S^* \to S$. Тем самым
мы заработаем пункт~4.

2. Для каждого терминала $a$ добавим нетерминал $A_a$ и правило \mbox{$A_a\to a$}.
Также заменим $a$ на $A_a$ в остальных правилах. Теперь в правых частях
правил у нас встречается либо только один терминал (как в пункте~2),
либо цепочка нетерминалов (почти как в пунктах~1 и~3).
Следующим шагом мы уменьшим длину этой цепочки до не более, чем двух символов. 

3. Пусть у нас есть правило $A\to BC\alpha$, где $\alpha$ --- 
непустая цепочка из нетерминалов. Добавим новый нетерминал $Z$, а правило заменим
на два других: $A\to BZ$ и $Z\to C\alpha$. Тем самым мы 
сократим правую часть правила на один символ. Продолжая действовать таким 
образом, добьемся нужной длины правой части.

4. Остается избавиться от правил
вида $A\to\epsilon$ (где $A\neq S^*$) и $A\to B$.
Аналогично лемме о праволинейных грамматиках
построим множества 
$S(B)=\{A\,|\,A\to^*B\}$ и 
$S(\epsilon)=\{A\,|\,A\to^*\epsilon\}$.
Заметим, что $A \in S(B)$ означает, что выполняется хотя бы одно из трех условий:\par
(1) $A=B$; \par
(2) $A\to C$, где $C\in S(B)$; \par
(3) $A\to CD$, где $C\in S(B)$, а $D\in S(\epsilon )$ (или наоборот).\par
Аналогично для $S(\epsilon)$.
Отсюда видно, что множества $S(\ldots)$ можно построить за конечное число
шагов: на каждом шаге мы будем для каждой пары нетерминалов $(A,B)$ 
проверять условия (1)--(3) и добавлять $A$ в $S(B)$,
если одно из условий выполнится (и то же самое --- для $S(\epsilon)$).
Если на очередном шаге мы ничего не добавим ни в одно из множеств, 
то множества $S(\ldots)$ построены.

Теперь для каждого $A\in S(B)$  и правила $B\to \alpha$ добавим 
правило $A\to \alpha$. Также, если $S^*\in S(\epsilon )$, то
добавим правило $S^*\to \epsilon$. После этого удалим все <<плохие>> правила,
т.е. правила вида $A\to\epsilon$ (где $A\neq S^*$) и $A\to B$.

\medskip
Заметим, что в результате наших действий язык не изменился. 
\end{proof}

\begin{definition}
Будем говорить, что грамматика --- в
\emph{нормальной форме Грейбах} (\emph{НФГ}),
если она содержит только
правила одного из следующих типов.
\begin{enumerate}
\item $A\to a$. 
\item $A\to aB$. 
\item $A\to aBC$. 
\item $S\to \epsilon$.
\end{enumerate}
Причем
\begin{enumerate}
\item[5.] Cтартовый символ $S$ в правых частях не встречается.
\end{enumerate}
\end{definition}

\begin{problem}
Доказать аналогичную теорему для НФГ.
\end{problem}

\subsection{Автоматы с магазинной памятью}
Как уже было доказано, любой праволинейной грамматике соответствует конечный 
автомат. Для бесконтекстной грамматики конечного автомата мало, 
поэтому мы усложним конструкцию автомата.

Наш автомат будет обладать памятью, а именно, магазином.
\emph{Магазин} представляет из себя стек,
с которым мы можем делать две вещи:\par
(1) достать верхний элемент; \par
(2) положить наверх данный элемент. \par

\begin{definition}
\emph{Недетерминированный автомат с магазинной памятью}
состоит из тех же частей, что и недетерминированный конечный автомат,
но надо добавить еще магазинный алфавит $M$ и начальный символ магазина
$Z\in M$. Функция перехода теперь такая:
$$\delta: Q\times (\Sigma\cup\{\epsilon\}) \times M\to 2^{Q\times M^*},$$ 
при этом требуется, чтобы значения $\delta$ были \emph{конечными}
множествами.
\end{definition}

Переход такого автомата мы будем 
записывать следующим образом: $q\step^{a,A/\alpha} p$. Это значит,
что $(p,\alpha )\in \delta (q,a,A)$. Фактически это означает следующее:
мы переходим из состояния $q$ в состояние $p$, считывая из строки символ $a$
(возможно, никакого символа вовсе не считываем: $a=\epsilon$).
При этом мы снимаем с магазина символ $A$, а на его место помещаем строку
$\alpha$. 

\emph{Конфигурацией} нашего автомата назовем тройку $(q,u,\gamma)$,
где $q\in Q$ --- текущее состояние, $u$ --- оставшаяся (непрочитанная)
часть строки, $\gamma$ --- содержимое магазина (верхний символ записывается
слева). Такт работы нашего автомата выглядит так:
$$(q,au,A\beta)\vdash (p,u,\alpha\beta),$$
если $q\step^{a,A/\alpha} p$ (здесь $a\in\Sigma\cup\{\epsilon\}$).
Будем говорить, что строка $x$ \emph{принимается автоматом}, если 
мы сможем из состояния $(q_s,x,Z)$ за конечное число шагов попасть в 
конечное состояние, исчерпав всю строку, т.е.
$$(q_s,x,Z)\vdash^* (q,\epsilon,\alpha)\qquad\mbox{(где $q\in F$)}.$$
При этом нам неважно, что именно у нас 
осталось в магазине.

\begin{example}
Построим автомат, задающий язык $\{0^n1^n\,|\,n\in\mathbb{N}\cup\{0\}\}$.
Он будет иметь четыре состояния:
начальное $q_s$, конечное $q_f$, и два промежуточных $q_1,q_2$;
а также следующие правила:\par
(1) $q_s\step^{\epsilon,Z/} q_f$ (чтобы не забыть о случае $n=0$);\par
(2) $q_s\step^{0,Z/0Z} q_1$;\par
(3) $q_1\step^{0,0/00} q_1$;\par
(4) $q_1\step^{1,0/} q_2$;\par
(5) $q_2\step^{1,0/} q_2$;\par
(6) $q_2\step^{\epsilon ,Z/} q_f$.
\medskip

Наш автомат действует следующим образом: считывая на очередном шаге 0,
мы кладем его в магазин; считывая 1, вынимаем 0 из магазина.
При этом, если единиц будет больше, чем нулей, 
то мы не сможем дочитать строку до конца;
а если наоборот, то мы не увидим дна магазина
и не попадем в конечное состояние.\qed
\end{example}

\begin{theorem}
По любой бесконтекстной грамматике можно построить недетерминированный
магазинный автомат, задающий тот же язык.
\end{theorem}
\begin{proof}
1. Приведем грамматику к НФХ.\par
2. В магазин автомата мы будем складывать нетерминалы;
наши состояния --- $q_s$ (стартовое), $q$ (<<рабочее>>)
и $q_f$ (конечное); а правилам вида (1)--(3) сопоставим, соответственно,
такие переходы:\par
(1) $q\step^{\epsilon ,A/BC} q$;\par
(2) $q\step^{a,A/\epsilon} q$;\par
(3) $q\step^{\epsilon ,S/\epsilon}q$.\par
А также добавим еще два правила: $q_s\step^{\epsilon ,Z/SZ} q$
(<<начинаем вывод со стартового символа>>) и 
$q\step^{\epsilon, Z/\epsilon} q_f$ (<<увидев дно магазина,
следует завершить вывод>>). Для того, чтобы убедиться,
что полученный автомат задает тот же самый язык,
достаточно доказать по индукции (упражнение)
следующую лемму.
\begin{lemma}
$(q,uv,\alpha \beta)\vdash^*(q,v,\beta)$ для нашего автомата
выполняется
тогда и только тогда, когда $\alpha\Rightarrow^* u$ для исходной грамматики
(в НФХ).
\end{lemma}
\end{proof}

\begin{problem}
Доказать обратную теорему.
\end{problem}

\subsection{Алгоритмические проблемы, связанные с бесконтекстными языками}

\paragraph{Алгоритм проверки принадлежности слова языку.} 
Цель --- проверить, принадлежит
ли слово $a_1a_2\ldots a_n$ языку, задаваемому грамматикой $G$
(очевидно, можно считать, что она --- в НФХ). 

Решать эту 
задачу мы будем методом динамического программирования. Обозначим $t_{ij}$ 
множество тех нетерминалов, из которых можно получить строку $a_i\ldots a_{i+j-1}$.
Множество ${t_{i1}}$ состоит из терминалов, для которых в $G$ имеется правило
$A\to a_i$. Для того, чтобы построить множество $t_{ij}$
будем разбивать строку по позиции $i+k-1$ и смотреть, из чего выводится каждая
из половинок. Иначе говоря, $A\in t_{ij}$, если существует правило 
$A\to BC$, где $B\in t_{ik}$ и $C\in t_{i+k,j-k}$.
Отсюда видно, что все множества $t_{ij}$ можно построить за кубическое
от длины строки количество шагов. При этом исходная строка принадлежит языку,
если стартовый символ лежит в множестве $t_{1n}$.

\paragraph{Проверка пустоты языка.}
Для решения этой задачи докажем следующую лемму:

\begin{lemma}[лемма о разрастании для бесконтекстных языков]
Для любого бесконтекстного языка $L$ существует 
число $k$, такое, что, если длина слова $\alpha$ больше чем $k$, то его можно
представить в виде $\alpha=xuvwy$, 
где длина слова $uvw$ --- менее $k$,
слово $uw$ не пусто,
и $xu^ivw^iy \in L$ для всех $i\ge0$.
\end{lemma}
\begin{proof}
Рассмотрим грамматику в НФХ, порождающую этот язык.
В качестве $k$ возьмем $2^{|N|+2}$. 

\begin{figure}

\vskip 1cm
\hrule
\vskip 5mm

\begin{verbatim}
                               S
                              /|\
                             / | \
                            /  |  \
                           /   B   \
                          /   /|\   \
                         /   / | \   \
                        /   /  |  \   \
                       /   /   B   \   \
                      /   /   / \   \   \
                     /   /   /   \   \   \
\end{verbatim}

\vskip -7mm
\centerline{$\!\underbrace{}_{x}$
$\underbrace{}_{u}$
$\underbrace{\phantom{WW}}_{v}$
$\,\underbrace{}_{w}$
$\underbrace{}_{y}$}

\caption{Разбиение $\alpha=xuvwy$. Пунктирная черта обозначает
<<границы>> соответствующего поддерева.}\label{fig:xuvwy}

\vskip 5mm
\hrule
\vskip 1cm

\end{figure}

Построим дерево вывода строки $\alpha$. В корень поместим стартовый символ $S$.
Потомками вершины, помеченной символом $X$, будут вершины,
помеченные символами правой части правила, которое было применено
для $X$ при выводе строки $\alpha$.
(Упорядочим их так же, как они были расположены в правой части правила.)
Листьями будут терминалы (символы строки $\alpha$).

По условию, в дереве $\ge2^{|N|+2}$ листьев,
поэтому его высота --- не менее $|N|+2$.
Значит, существует путь из корня в лист такой длины.
Тогда на этом пути какой-то нетерминал $B$ встретится дважды.

Рассмотрим основное дерево, а также получившиеся
два поддерева с корнями в вершинах, где сидит этот символ.
В результате слово разобьется на необходимые нам пять частей
(см. рис.~\ref{fig:xuvwy}).
По построению, $B\Rightarrow^*uBw$ и $B\Rightarrow^*v$.
Слово $uw$ непусто, поскольку грамматика была в НФХ.

Осталось добиться того, чтобы выполнялось $|uvw|< k$.
\begin{problem}
Сделать это.
\end{problem}
\end{proof}

Теперь легко проверить пустоту языка. Если язык не является пустым, то в нем должна 
существовать строка длины меньшей, чем $k$
(пока строка удовлетворяет лемме,
ее можно при помощи леммы заменять на другую строку, меньшую по длине),
а количество таких строк конечно.
Итого нам надо будет лишь конечное число раз запустить алгоритм,
распознающий принадлежность строки нашему языку.

\end{document}

