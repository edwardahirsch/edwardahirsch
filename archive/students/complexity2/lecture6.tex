\documentclass[12pt,fleqn,a4paper]{book}
% 
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{epsf}
\advance\textheight by 5mm
%
% Common customization:
%
\input defs
\newcommand{\sq}{\frac{1}{\sqrt2}}
\newcommand{\qz}{\left|0\right>} \newcommand{\qo}{\left|1\right>}
\newcommand{\qx}{\left|x_0\right>}
\newcommand{\qks}{\left|\xi\right>}
\newcommand{\qzz}{\left|00\right>}
\newcommand{\qoz}{\left|10\right>}
\newcommand{\qzo}{\left|01\right>}
\newcommand{\qoo}{\left|11\right>}
\newcommand{\sN}{\frac{1}{\sqrt{N}}}
%
% The document
%
\begin{document}
\selectlanguage{russian}
\lecture{6}{Квантовые алгоритмы}{И. Посов}
\section{Квантовые вычисления}
\begin{figure}[!b]
\epsffile{lecture6-01.ps}
\caption{место $\BQP$ среди других классов}\label{fig:1}
\end{figure}

Будем изучать класс сложности $\BQP$ --- языков, принимаемых
полиномиальными квантовыми алгоритмами с ограниченной двусторонней ошибкой.
На рисунке~\ref{fig:1} видно
его расположение по отношению к другим классам сложности. Скорее
всего, $\BQP\neq\PP$. Из обратного ($\BQP =\PP$) следует, что
$\PH\subseteq\PP$. Также неизвестно, содержится ли $\NP$ в $\BQP$.


Вспомним, что такое детерминированные классические вычисления. У
нас есть машина Тьюринга и какой-то фиксированный вход (лента с
конкретными символами). По внутреннему состоянию машины и текущему
символу с ленты однозначно определено следующее внутреннее
состояние, выходной символ и изменение положения считывающей/пишущей
головки. Но в данном конспекте будем понимать это несколько иначе.
Головки не будет, но при этом мы разрешим за один раз
считывать и записывать информацию сразу из нескольких мест. Важно,
чтобы этих мест было не очень много, т.е. не больше некоторой
константы. Все сказанное означает, что у нас есть вычисляющая
машина, которая за шаг смотрит на некоторое число ячеек на ленте
и в зависимости от своего внутреннего состояния изменяет эти
ячейки и свое внутреннее состояние. Можно легко показать, что
такая машина <<эквивалентна>> машине Тьюринга, т.е. они друг друга
полиномиально моделируют.

Если машина работает полиномальное время, то она использует лишь полиномиальное
число ячеек на ленте. Внутренних состояний --- константное число,
так что можно считать, что полиномиальным (от входа) числом
битов можно записать полное состояние машины. Каждая такая
конфигурация (состояние ленты и внутреннее состояние) однозначно
определяет следующую конфигурацию машины. Изобразим это в виде
матрицы $C$ из $0$ и $1$ таким образом, что в позиции $C_{c_j,c_i}$
стоит $1$ тогда и только тогда, когда из конфигурации $c_i$ можно
за один шаг перейти в $c_j$. Таким образом, в
каждом столбце стоит ровно одна $1$.

Теперь введем вектор конфигураций. Это столбец из $1$ и $0$, в
котором ровно одна $1$, положение которой сответствует той
конфигурации, в котором находится машина. Например, в двумерном
случае столбец $(1,0,0,0)^t$ означает, что она находится в
конфигурации $00$, столбец $(0,1,0,0)^t$ означает конфигурацию $01$,
столбец $(0,0,1,0)^t$ означает конфигурацию $10$ и, наконец, столбец
$(0,0,0,1)^t$ означает конфигурацию $11$. Что будет если матрицу $C$
умножить на вектор конфигураций? Это эквивалентно одному шагу
машины, т.е. $1$ переместится из одного места в другое, что
соответствует переходу машины из состояния в состояние. В
результате получается, что машина работает таким образом:
изначально есть вектор конфигураций, соответствующий начальной
конфигурации машины. За один шаг вектор умножается на матрицу $C$.

В дальнейшем мы будем путать термины <<состояние>> и <<конфигурация>>
(при этом всегда будем иметь в виду последнее).

В вероятностных вычислениях все практически также. Только здесь
для состояния известно не то, в какое конкретно  состояние 
переходит машина, а определены вероятности перехода из данного
состояния во все другие
состояния. Зададим матрицу $C$ так, что в позиции $c_j,c_i$ стоит
вероятность перехода из состояния $c_i$ в состояние $c_j$. Сумма
элементов в столбцах должна будет оказаться $1$. Вектор состояний
--- это вектор, где в позиции $c_i$ находится вероятность
нахождения машины в состоянии $c_i$. Изначально вектор таков, что
в позиции, соответствующей начальному состоянию стоит $1$, а во
всех остальных местах --- $0$. Это означает, что в начальный
момент времени машина наверняка находится в начальном состоянии.
Шаг вычисления --- это умножение вектора справа на матрицу $C$.
Очевидно, что после $k$ умножений в позиции $c_i$ вектора будет
находится вероятность того, что через $k$ шагов после начала
машина окажется в состоянии $c_i$. Детерминированные вычисления
являются частным случаем вероятностных.

И, наконец, квантовые вычисления. Здесь все полностью повторяет
предыдущее, но элементы матрицы $C$ теперь уже будут комплексными.
Элементы вектора состояний --- это не вероятности соответствующих
состояний, а их амплитуды. Амплитуда --- это как бы корень из
вероятности (если мы прервем вычисление и посмотрим, что же получилось,
то мы увидим конфигурацию $c_i$ с вероятностью $1/|a_i|^2$, где
$a_i$ --- амплитуда конфигурации $c_i$).
Таким образом, вектор состояний всегда должен иметь
единичную длину. (Сумма квадратов элементов равна $1$) Столбцы
матрицы $C$ тоже должны иметь единичную длину, чтобы после
умножения ее на вектор, он оставался единичной длины. Таким
образом, матрица $C$ имеет столбцы единичной длины, сохраняет длины
векторов и, тем самым, является унитарным оператором. Заметим также, что
матрица $C$ должна быть обратима. 

Как получена матрица $C$? Так же, как и матрица для детерминированного
или вероятностного вычисления: именно, за один шаг она должна воздействовать
на амплитуды лишь константного числа битов, при этом ее действие также
должно зависеть лишь от константного числа битов (на разных шагах алгоритма 
--- от разных!). Например, ее можно построить так (и мы будем этим
пользоваться):
взять конкретные матрицы $C_i$, воздействующие
на конкретные маленькие множества позиций конфигурации,
и построить их произведение. Чтобы это произведение
реализовать в вышеприведенной модели, понадобится дополнительная
память: счетчик шагов (наша машина должна знать, каков номер шага,
чтобы знать, какую из $C_i$ применять).
Тем самым, если выделить столбцы и строки 
матрицы $C$, соответствующие шагам $i$ и $i+1$,
и переупорядочить оставшуюся память так, чтобы задействованные в $C_i$ биты 
находились в конце конфигурации, получится матрица
$$
\begin{array}{cccc}
     &&     i    &i+1\\
     &&    \downarrow&\downarrow\\
 i   &\rightarrow&     0    & 0 \\
i+1  &\rightarrow&    C_i   & \phantom{,}0, 
\end{array}
$$
Причем $C_i$ будет 
выглядеть как блочно-диагональная
матрица с одинаковыми блоками константного размера
$2^{\mbox{\small{}количество задействованных битов}}$.
Даже после таких ухищрений видно, что, строго говоря,
на каждом шаге может изменяться много битов: прибавление
единицы к счетчику может вызвать перенос разряда \Retc,
но это-то мы уже сможем разложить на элементарные операции
(формально, вновь увеличив матрицу $C$).

Итак, квантовое вычисление ---
это последовательность квантовых воздействий на константное число
квантовых битов.

\begin{definition}
Язык принадлежит классу $\BQP$, если $\exists$ квантовый
полиномиальный по времени алгоритм, который ошибается с
ограниченной вероятностью ($1/4$, например).
\end{definition}

Возникают проблемы.

\begin{enumerate}
\item Можно ли вложить детерминированные вычисления в квантовые? Как
уже говорилось, матрица $C$ для квантового вычисления должна быть
обратимой, а для детерминированного --- не обязательно. Эта
проблема решается. Можно пользоваться дополнительной памятью, т.е.
увеличить длину квантовой ленты и за счет этого сделать матрицу
обратимой (размер матрицы тоже увеличится). %И вообще, квантовость
%предполагает неопределенность состояния, и не сразу понятно,
%например, что значит проверить, все ли q-биты равны $0$.

\item Что будет, если в середине работы посмотреть промежуточный
результат, повлияет ли это на окончательный результат?
На самом деле, смотреть на конфигурацию
<<классически>> в середине работы --- ни к чему.

\item Нужно ли так много амплитуд? Вместо $\mathbb{C}$, можно использовать
множество амплитуд $\{-1,-\sq,0,\sq,1\}$ Можно доказать, что
вычислительная сила машины не изменится.

\item Можно ли увеличить вероятность получения правильного ответа,
повторив квантовый алгоритм несколько раз? Ответ: да. Но это не столь 
же очевидно, сколь в вероятностном случае.

\item Существует ли универсальная квантовая машина Тьюринга? Да, но
ее конструкция технически сложна.
\end{enumerate}

Квантовый бит (q-бит), в отличие от обычного, находится не в
конкретном состоянии $1$ или $0$, как обычный, а одновременно в
обоих с некоторыми амплитудами. Записывается это так:
$\sq\left|0\right>-\sq\left|1\right>$, т.е.
q-бит --- это элемент линейного пространства,
базисные вектора $(1,0)^t$ (бит находится в состоянии $0$)
и $(0,1)^t$ (бит находится в состоянии $1$) которого обозначаются
$\left|0\right>$ и $\left|1\right>$. (По существу, это точно
так же для памяти вероятностных алгоритмов: каждый символ
на ленте --- случайная переменная; просто в терминах
линейных пространств о них обычно не рассуждают.)

Несколько q-битов
--- квантовый вектор. Пример:
$\sq\left|00\right>-\sq\left|10\right>$. Первый q-бит здесь
находится в состоянии $\sq\left|0\right>-\sq\left|1\right>$, а второй 
точно является нулем.
%, т.к.  амплитуды $\left|0\right>$ и $\left|1\right>$ являются
% соответствующими суммами.
Если квантовый вектор имеет вид
$\sum_{x=00..0}^{11..1}{\lambda_x\left|x\right>}$, то, например,
первый бит имеет вид:
$\sum_{x=00..0}^{01..1}{\lambda_x\left|0\right>} +
\sum_{x=10..0}^{11..1}{\lambda_x\left|1\right>}$. Квантовая конфигурация
нашего квантового компьютера является как раз квантовым вектором.

Состояния вида $\left|x\right>$, (где одна амплитуда равна $1$, а
остальные $0$) называются чистыми (или классическими). Измеряя состояние, в смысле
смотря ответ, мы получаем как раз такое состояние.
Если проводится измерение, амплитуда состояния
определяет только вероятность его появления.

\section{Алгоритм Гровера}
\paragraph{Постановка задачи.}
Теперь опишем алгоритм поиска в абстрактной базе данных. Пусть
есть предикат $\mathcal{U}: \{0,1\}^n \longrightarrow \{0,1\}$. Надо найти
вход, на котором ответ равен $1$. Для простоты (и только для нее)
будем считать, что такой вход ровно один. В
классических случаях пришлось бы произвести $\Omega(2^n)$ шагов, 
квантовом достаточно $O(2^{n/2})$.

\paragraph{Оператор $U$.}
Предикат наш должен быть квантовым,
он будет воздействовать на нашу систему в целом,
\[
U\left| x\right> = 
\begin{cases}
\phantom{-}\left|x\right>,& x\neq x_0\\
-\left|x\right>,& x=x_0
\end{cases}
\]
($x_0$ --- как раз такой, что $\mathcal{U}(x_0)=1$). Матрица
$U$ имеет вид диагональной, где все элементы равны $1$, кроме
одного, равного $-1$. Эта $-1$ как раз находится в строке и
столбце $x_0$. Мы определили $U$ на базисных (чистых) состояниях.
По линейности он определен и на всех остальных: например,
$U(\sq\left|x_0\right>-\sq\left|x\right>)
=-\sq\left|x_0\right>-\sq\left|x\right>$.

\paragraph{Оператор $W$.}
Итак, изначально у нас состояние $\left|00\ldots0\right>$. Теперь
определим оператор $W$. Он будет делать из нулевого --- случайный вектор
(квантовых случайных векторов, правда, много (знаки амплитуд!); нам нужен
некий конкретный).
Определим операцию над одним битом: $$S' = \begin{array}{ccc}
&\qz&\qo\\\qz&\sq&\sq \\\qo& \sq&-\sq. \end{array} $$ 
Напомним, что для того, чтобы оформить ее в виде матрицы,
действующей на все состояние, надо построить блочно-диагональную
(с точностью до перестановки битов) матрицу;
например, для конфигурации из двух битов подействовать матрицей $S'$
на последний бит можно так:
$$S_1= \begin{array}{ccccc} &\qzz&\qzo&\qoz&\qoo\\\qzz&\sq&\sq&0&0
\\\qzo&\sq&-\sq&0&0\\\qoz&0&0&\sq&\sq\\\qoo&0&0&\sq&-\sq
\end{array}.$$ Итак, после этого преобразования второй q-бит, если
он был $\qz$, станет $\sq\qz+\sq\qo$, а если он был $\qo$, то он
станет $\sq\qz-\sq\qo$. (Это как бы значит, что он равен $\qz$ и
$\qo$ с верятностями $\frac12$.) Чтобы преобразовать первый q-бит,
надо <<умножить>>\footnote{См. выше замечание о счетчике шагов,
но, абстрагируясь от этого, можно считать, что мы именно перемножаем
матрицы: эффект воздействия на биты, отличные от счетчика шагов,
будет именно таков, как дало бы произведение матриц.}
на матрицу $S_2$ ($S_1$ с переставленными блоками,
чтобы изменился именно первый q-бит). И так далее. После $n$
умножений наш исходный вектор $\left|00\ldots0\right>$ превратится
в $\sum_x{\sN\left|x\right>}$ (обозначим его $\qks$),
где $N = 2^n$. Пусть $W =
S_1\cdot S_2\cdot\ldots\cdot S_n$.

\paragraph{Оператор $Z$.}
Определим оператор $Z$ так, как будто бы это $U$, но обращающий 
амплитуду не $x_0$, а
$0$. Он делается моделированием детерминированного вычисления внутри
квантового. Надо устроить дополнительную память, в один из битов которой после
$n$ шагов проверки запишем, является ли текущий вектор полностью
нулевым; потом же 
в зависимости от значения этого бита обратим амплитуду нашего вектора или нет.
\begin{exercise}
Выписать квантовый оператор, соответствующий этому (не)обращению амплитуды.
\end{exercise}
Итоговая матрица (про дополнительную память забыли) получится такой: $$Z =
\begin{array}{cccc}-1&0&\cdots&0\\0&1&\cdots&0\\
\vdots&\vdots&\ddots&\vdots\\0&0&\cdots&1\end{array}.$$
(Сразу так задавать $Z$ было нельзя, т.к. получилось бы, что машина
смотрит одновременно
сразу на {\it всю} строку, чтоб решить, писать перед ней минус,
или нет. Мы же разложили это на элементарные действия
при помощи дополнительной памяти, о которой затем забыли.)

\paragraph{Оператор $V$.}
Определим, наконец, $V = W^{-1}ZW = WZW$ (ведь $W=W^{-1}$). 

\paragraph{Собственно алгоритм.}
Теперь
алгоритм таков: $${(VU)}^{k}\, W\qz.$$ Утверждается, что если
применить $VU$ порядка $k\approx\sqrt N$ раз, то с большой вероятностью
мы увидим конфигурацию $\left| x_0\right>$.

\paragraph{Анализ алгоритма.}
Посчитаем: 
\begin{eqnarray*}
U\qks &=& \qks - \frac2{\sqrt N}\left|x_0\right>,\\
U\left|x_0\right>&=&-\left|x_0\right>,\\[+3mm]
V\qks&=&WZW\qks=WZ\qz=W(-\qz)=-\qks,\\
V\left|x_0\right>&=&\ldots=\left|x_0\right>-\frac2{\sqrt N}\qks.
\end{eqnarray*}

Таким образом, мы не выходим из подпространства, натянутого на
вектора $\qks$ и $\qx$. Пусть дан вектор $q=\alpha\qks+\beta\qx$.
\begin{eqnarray*}
U(\alpha\qks+\beta\qx)&=&\alpha\qks-\left(\frac2{\sqrt
N}\alpha+\beta\right)\qx,\\
V(\alpha\qks+\beta\qx)&=&-\left(\alpha+\frac{2\beta}{\sqrt N
}\right)\qks+\beta\qx.
\end{eqnarray*}

\begin{figure}
\epsffile{lecture6-02.ps}
\caption{применение операторов $U$ и $V$}\label{fig:2}
\end{figure}

Т.е. $U$ оставляет координату при $\qks$, а $V$ --- при $\qx$. Мы
также помним, что все операторы должны сохранять длины векторов.
Смотрим на рисунок~\ref{fig:2}. Немного подумав, понятно, что
$\varphi+\psi=\frac\pi2$; $\cos\varphi=\qks\cdot\qx$ (скалярное
произведение). Т.е. $\cos\varphi=\sN$, т.е.
$\varphi\approx\frac\pi2 \Rightarrow \sin\psi\approx\sN
\Rightarrow 2\psi\approx\frac2{\sqrt N}$. Сделав два поворота
(т.е. $V(U(V(U(q))))$), мы повернемся на угол $\approx\frac4{\sqrt
N }$. Начинаем мы на $W\qz=\qks$. Т.е. надо повернуться на угол
$\approx \frac\pi2$, чтобы получить почти $\qx$. Т.е. надо сделать
около $\frac\pi2 / \frac4{\sqrt N} = \frac\pi8\sqrt N$ поворотов
$(VU)^2$.

Ошибка вылезает из разных мест ($\varphi\neq\pi/2 \Rightarrow \sin x \neq
x$, а количество поворотов --- нецелое), но она порядка $\sN$,
т.е. амплитуда интересующего нас вектора достаточно близка к $1$.

%Осталась одна проблема, в самом начале мы обещали, что умножать мы
%будем на одну и ту же матрицу, меняющую мало битов за раз, а здесь
%у нас $W$,$Z$ --- это произведение таких матриц. Проблема решается
%введением дополнительной памяти со счетчиком. Посмотрим на примере
%как работает склеивание 3 матриц $A_1$, $A_2$, $A_3$:
%
%$$\begin{array}{cccc}0&0&0&E\\A_1&0&0&0\\0&A_2&0&0\\0&0&A_3&0\end{array}$$
%
%$E$~--- единичная матрица. Вот. При первом умножении мы как бы
%умножили на $A_1$, при втором~--- на $A_2$ и далее по циклу.

\end{document}
