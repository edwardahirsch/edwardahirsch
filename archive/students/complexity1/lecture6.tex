\documentclass[12pt,fleqn,a4paper]{book}
% 
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
%
% Common customization:
%
\input defs
%
% The document
%
\begin{document}
\selectlanguage{russian}
%
% Lecture title
%
\lecture{6}{Вероятностные алгоритмы. Булевы схемы}{С. Федин}

%
% The lecture
%
\section{Булевы схемы}
\begin{definition}
Булевой схемой $C$ называется ориентированный граф без (ориентированных) циклов, 
вершины которого помечены входными битами 
$x_1, x_2, \ldots, x_m$ и булевыми операциями $\lor$, $\land$, $\lnot$;
одна выделенная вершина является выходом.
Вершины этого графа называются гейтами,
во входные гейты не ведет ни одно ребро,
из выходного гейта не исходит ни одного ребра. %и в который ведет ровно одно ребро).
%Гейты помечены символами по следующим правилам: входные 
%гейты помечены символами $x_i$, а все остальные помечены булевыми операциями, причем 
Входная степень гейта должна
совпадать с количеством аргументов той операции, которой она помечена
(так, например, в гейт помеченный $\lnot$ должно входить ровно 
одно ребро, а в гейт, помеченный $\lor$ или $\land$,
должно входить ровно два ребра).

Вычисления в булевой схеме происходят следующим образом: на входные гейты
подается набор $X \in \{0,1\}^m$ значений переменных 
$x_i \ (i \in 1..m)$; значение в каждом следующем гейте определяется
через значения в гейтах, из которых выходят ребра в данный гейт:
например, если в гейт, помеченный $\lor$,
входят ребра из гейтов, значения в которых равны $y_1$ и $y_2$, то значение
в этом гейте равно $y_1 \lor y_2$. 
Результатом вычисления схемы является значение, вычисленное в выходном гейте.  
\end{definition}

Определим теперь класс $\Ppoly$, состоящий из булевых схем полиномиального размера.
\begin{definition}
$L\in \Ppoly$ если существует семейство схем
$ \{C_i\}_{i \in \mathbb{N}}$ и полином $p$,
такие что $\forall i\ |C_i| \leq p(i)$ и 
$x \in L \Leftrightarrow C_{|x|}(x) = 1.$ 
\end{definition}

Альтернативное определение:
\begin{definition}\label{def:Ppoly-wit}
Класс $\Ppoly$ состоит из тех языков $L$,
принимамых недетерминированной машиной Тьюринга,
подсказка которой не зависит от входа (но может зависеть от его длины),
т.е. имеется полиномиально вычислимое отношение $R$, для которого
\[\exists \{y_i\}_{i\in\mathbb{N}}\ 
\forall x\ (x\in L \Leftrightarrow R(x,y_{|x|})=1).\]
\end{definition}

Нетрудно видеть, что эти определения эквивалентны.


Хотелось бы понять взаимосвязь классов $\P$ и $\NP$
с новым классом $\Ppoly$. Очевидно, что $\P \subseteq \Ppoly$.
Легко увидеть, что $\P\neq\Ppoly$ (ведь $\Ppoly$ содержит даже
некоторые языки, проблема принадлежности которым алгоритмически
неразрешима). Вопрос $\NP\mathop{\subseteq}\limits^?\Ppoly$ открыт.
Однако он не является совершенно независимым вопросом.

\begin{theorem}
$\NP \subseteq \Ppoly \Rightarrow \PH = \SigmaP{2}$.
\begin{proof}[Доказательство\footnote{Возможно, в курсе было другое доказательство!}.]

Рассмотрим $\SigmaP{3}$-полный язык
\begin{equation}\label{eq:yzF}
L=\{\textrm{$F$ --- формула в КНФ}\,|\,\exists x\forall y\exists z F(x,y,z)\}.
\end{equation}
Достаточно показать, что он лежит в $\SigmaP{2}$.

Действительно, пусть $\NP\subseteq\Ppoly$.
Тогда для $\SAT$ имеются схемы полиномиального размера.
При помощи их мы и справимся с формулой $F$.
Правда, они нам не даны; поэтому мы изобретем их при помощи
квантора $\exists$ и проверим их корректность при помощи квантора $\forall$.
Корректность семейства схем для $\SAT$ можно проверить
(у нас есть квантор всеобщности!),
зная, что для любой формулы $G$ и переменной $k$ выполняется 
$G=G[k:=0]\lor G[k:=1]$ --- две последние формулы --- меньше,
и их можно проверить схемой меньшего размера (и$\;$т$\;$д. до тривиальных).
Более формально, семейство схем $\{C_i\}_{i=1}^n$ корректно
для формулы $w$ длины $n$, если для каждой переменной $k$
выполняется
$C_{|w|}(w)=C_{|w[k:=0]|}(w[k:=0])\lor C_{|w[k:=1]|}(w[k:=1])$,
а если $w$ вовсе не содержит переменных,
то $C_{|w|}(w)$ выдает соответствующую
константу ($\mathtt{true}$ или $\mathtt{false}$).

Итак, следующее выражение доказывает, что $L\in\SigmaP{2}$:

\bigskip
\noindent
$\exists$ схемы $C_1, \ldots, C_n$ 
для входов размера $1,\ldots, n$ соответственно;\\
$\exists x$ (это строка как в (\ref{eq:yzF}));\\[5pt] 
\centerline{такие, что}\\[5pt]
$\forall y$ (это строка как в (\ref{eq:yzF}));\\ 
$\forall w$ --- булевой формулы длины $\le n$;\\[5pt]
\centerline{семейство $\{C_i\}$ корректно для выражения $w$ и}\\
\centerline{$C_{|F|}(F(x,y,z))=1$.}
\bigskip

(В последнем выражении свободные переменные --- только $z$!)

%Достаточно взять $\SigmaP{3}$-полный язык и показать,
%что он лежит в $\SigmaP{2}$. 
%Мы знаем такой язык:
%Рассмотрим 
%$\SigmaP{3}$-полную задачу выполнимости булевой 
%формулы с тремя кванторами, а именно $\exists\forall\exists\SAT$,
%т.е. вопрос об истинности формулы вида $$\exists x\forall y\exists z F(x,y,z).$$ 
%\ref{?}
%Напишем формулу, вычислимую в $\Sigma^2P$,
%эквивалентную формуле, вычилимой в $\Sigma^3P$: 
\end{proof}

\end{theorem}

Эту теорему можно переформулировать следующим образом:
\begin{theorem}
$\NP \subseteq \Ppoly \Leftrightarrow  \exists $ 
редкое $\NP$-трудное множество в смысле сводимости по Куку.
\end{theorem}

\begin{proof}
Достаточно доказать,
что $\SAT \in \Ppoly \Leftrightarrow \SAT$ сводится по Куку к редкому множеству.

\emph{Необходимость.}
Пусть $\SAT\in\Ppoly$. %$\NP\subseteq\Ppoly$. Тогда $\SAT \in \NP \subseteq \Ppoly$.
Зафиксируем
семейство схем $\{C_i\}_{i \in \mathbb{N}}$ полиномиального размера
(можно считать, что размер схемы $C_i$ --- \emph{ровно} $p(i)=dc^i$)
для языка $\SAT$. Построим теперь требуемое редкое множество $L$.
Закодируем все схемы, и будем составлять множество $L$ из кодов всех схем
и всех их префиксов т.е. для схемы $C_n$ с 
кодом $a_1a_2\ldots a_{p(n)}$ (где $a_i \in \{0,1\}$) в множество $L$ попадут: 
$a_1a_2\ldots a_{p(n)}$, 
$a_1a_2\ldots a_{p(n)-1}\texttt{\#}$, 
$a_1a_2\ldots a_{p(n)-2}\texttt{\#\#}$, 
\ldots, 
$a_1\texttt{\#}^{p(n)-1}$. 
Понятно, что построенное множество редко 
(для данной длины строки $p(n)$
в множество $L$ попадает одна схема и $p(n)-1$ ее префиксов).
Теперь, используя $L$ как оракул,
можно найти схему нужного размера:
спросим его $0\texttt{\#}^{p(|x|)-1}\mathop{\in}\limits^? L$,
если он ответит <<да>>, то спросим $00\texttt{\#}^{p(|x|)-2}$; 
если <<нет>>, то $10\texttt{\#}^{p(|x|)-1}$ и$\;$т.$\;$д.
%Если ответом оракула на $i$-й запрос $s_{i-1}0\#^{p(|x|)-i}$ будет "да", то $(i+1)$-й запрос будет $s_{i-1}00\#^{p(|x|)-i-1}$, 
%а если "нет", то $s_{i-1}10\#^{p(|x|)-i-1}$.
Итак, задав $p(|x|)$ запросов оракулу, мы построим схему $C_{|x|}$.
Остается промоделировать ее вычисления на входе $x$
на детерминированной машине Тьюринга.

\emph{Достаточность.}
Пусть у нас имеется $\NP$-трудное редкое множество $L$, к которому сводится $\SAT$. 
Докажем, что $\SAT \in \Ppoly$, пользуясь определением~\ref{def:Ppoly-wit}.
В качестве подсказки $y_i$ возьмем все строчки из $L$ 
размера $i$ (объединенные в одну: $l_1\texttt{\#} l_2 \texttt{\#} l_3 \ldots$.
Поскольку $L$ --- редкое множество,
суммарная длина такой подсказки $y_i$ ограничена некоторым полиномом. 
\end{proof}

\section{Вероятностные алгоритмы}
\begin{definition} Язык $L$ принадлежит классу $\RP$,
если существует вероятностный
полиномиальный по времени алгоритм, который для $x \in L$
принимает с вероятностью $\geq\frac{3}{4}$, 
а для $x \notin L$ отвергает с вероятностью $1$.
\end{definition}

\begin{remark}
Класс $\RP$ не изменится, если в определении заменить константу $\frac{3}{4}$
на любую другую, не равную $0$ и $1$.
\end{remark}

\begin{remark}
Можно сделать, чтобы такой алгоритм <<врал>> 
со сколь угодно маленькой вероятностью.
Действительно, повторив вычисления $k$ раз
и ответив <<да>> если хотя бы один раз вычисление было принимающим,
мы получим вероятность ошибки не более $\frac{1}{4^k}$.
\end{remark}

\begin{definition}
Язык $L$ принадлежит классу $\BPP$,
если существует вероятностный алгоритм, который для $x \in L$
принимает с вероятностью $\geq\frac{3}{4}$,
а для $x \notin L$ отвергает с вероятностью $\geq\frac{3}{4}$.
Другими словами, существует алгоритм,
выдающий правильный ответ с вероятностью $\geq {\frac{3}{4}}$.
\end{definition}

\begin{remark}
Класс $\BPP$ не изменится, если в определении заменить константу
$\frac{3}{4}$ на любую другую \emph{константу}, строго большую $\frac{1}{2}$.
\end{remark}

\begin{remark}
Снова можно сделать так, чтобы вероятность ошибки была экспоненциально мала.
Повторим вычисления $k$ раз и окончательный
результат будем давать мнением большинства.
Для доказательства того, что в итоге вероятность ошибки мала,
воспользуемся неравенством Чернова.
\begin{fact}
$$
P\{X>(1+\varepsilon)pk\}<\left(\frac{e^\varepsilon}{(1+\varepsilon)^{1+\varepsilon}
}\right)^{pk}
\leq e^{-\frac{pk\varepsilon^2}4},
$$
%$$P\{x>(1+\epsilon)pk\} \leq e^{-{{pk}\over{\epsilon ^2}}c},$$ 
где
$X = \sum_{i=1}^{k}x_i$, а 
$x_i$ --- независимые случайные величины,
которые равны 1 и 0 с вероятностями $p$ и $(1-p)$ соответственно.
\end{fact}
Правая часть этого неравенства --- это вероятность того, что <<многие>> $x_i = 1$. 
В нашем случае $x_k = 1$ соответствует неправильному ответу
в $k$-ом вычислении; вероятность ошибки $p = {\frac{1}{4}}$.
Возьмем $\epsilon=1$. Тогда, неравенство
имеет вид: $P\{{X > \frac{1}{2}}k\} \leq e^{-{\frac{k}{16}}}=2^{-\Omega(k)}$.
Итак, для того, 
чтобы получить вероятность ошибки
$\frac{1}{2^m}$, достаточно повторить вычисления $k = O(m)$ раз.
\end{remark}

\begin{definition}
Класс задач, для которых есть алгоритмы
с нулевой вероятностью ошибки: $\ZPP = \RP \cap \co\RP$.
\end{definition}

\begin{exercise}
Для определения $x\in L$ для $L\in\ZPP$ будем запускать 
соответствующие алгоритмы
из $\RP$ и $\co\RP$ параллельно,
пока хотя бы один из них не даст тот ответ,
в котором он заведомо не <<врет>>.
Докажите, что математическое ожидание
времени, которое пройдет до этого момента, полиномиально.
\qed
\end{exercise}

Классы, определенные выше, можно определить по-другому, с помощью отношений:

\begin{definition}
$L\in\RP$, если имеется полиномиально проверяемое отношение $R$,
ограниченное полиномом $p$, такое, что
если $x \in L$, то для по крайней мере $\frac{3}{4}$ всех возможных
подсказок $y$ длины $p(|x|)$ выполнено $R(x,y)=1$;
если $x \notin L$, то для любой подсказки --- $R(x,y)=0$.
\end{definition}

\begin{definition}
$L\in\BPP$, если имеется полиномиально проверяемое отношение $R$,
ограниченное полиномом $p$, такое, что
если $x \in L$, то для по крайней мере $\frac{3}{4}$ всех возможных
подсказок $y$ длины $p(|x|)$ выполнено $R(x,y)=1$;
если $x \notin L$, то для 
по крайней мере $\frac{3}{4}$ всех возможных
подсказок $y$ длины $p(|x|)$ выполнено $R(x,y)=0$.
\end{definition}

\begin{remark}\label{rem:PTM}
Сравним классы $\RP$ и $\BPP$ с $\NP$.
Для $\NP$ надо было, 
чтобы хотя бы в одном листе дерева вычислений 
машины Тьюринга была $1$ для слова из языка, и все $0$ --- для слова не из языка.
Для $\RP$ надо, чтобы доля единиц была хотя бы $\frac{3}{4}$ 
для слова из языка, и все нули --- для слова не из языка.
Для $\BPP$ --- доля $\frac{3}{4}$ единиц и 
доля $\frac{3}{4}$ нулей для слова из языка и не из языка соответственно. 
\end{remark}

\begin{definition}
Замечание~\ref{rem:PTM} дает возможность определить $\RP$ и $\BPP$
при помощи недетерминированных машин Тьюринга (полиномиальных по времени).
\end{definition}

Определим еще один класс, $\class{BPP/poly}$:
класс схем, которым разрешено пользоваться случайными числами.
\begin{definition}
$L\in \class{BPP/poly}$,
если существует семейство схем $ \{C_i\}_{i \in N}$
и полином $p$, такой, что для $\forall i\ |C_i| \leq p(i)$ и 
$x \in L$ тогда и только тогда, когда для хотя бы 
$\frac{3}{4}$ случайных строчек $y$ выполнено $C_{|x|}(x,y) = 1$;
$x \notin L$ тогда и только тогда, когда для хотя бы 
$\frac{3}{4}$ случайных строчек $y$ выполнено $C_{|x|}(x,y) = 0$.
\end{definition}

\begin{remark}
Повторяя вычисления на схеме <<много>> раз,
можно добиться, чтобы вероятность ошибки была экспоненциально мала.
\end{remark}

Верно следующее утверждение:
\begin{theorem}
$\BPP\subseteq \class{BPP/poly} = \Ppoly$.
\end{theorem}
\begin{proof}
Достаточно доказать $\class{BPP/poly}\subseteq\Ppoly$.
Пусть нам дано семейство схем из $\class{BPP/poly}$;
потребуем, чтобы вероятность ошибки была не более $1 - {\frac{1}{2^{2n}}}$. 
Заметим, что для конкретного входа $x$ длины $n$ 
<<хороших>> случайных строчек $y$ (т.е. таких строчек,
что если они попались на вход, то схема выдаст правильный ответ)
имеется не менее
$1 - \frac1{ 2^{2n}}$
от всех возможных $y$ (длины, используемой схемой для входа $x$ длины $n$). 
Покажем, что существует строчка $y$,
для которой схема дает правильный ответ для всех 
входов $x$ данной длины (она и будет подсказкой для этой длины).

Рассмотрим некую случайную строчку.
Заметим, что для конкретного $x$ длины $n$ эта строчка 
<<плоха>> с вероятностью $\frac1{2^{2n}}$.
Значит, вероятность, что она будет <<плоха>> хотя бы для одного входа
длины $n$, составляет не более 
$2^n{\frac1{2^{2n}}} = {\frac1{{2^n}}} < 1$.
Таким образом, вероятность того, что эта строчка <<хороша>>
для всех входов данной длины --- строго положительна.
Следовательно, такая строчка существует!
\end{proof}

\begin{theorem}
$\BPP \subseteq \SigmaP{2}$.
\end{theorem}

\begin{proof}
Пусть $L \in \BPP$. 
%Тогда $$x \in L \Rightarrow R(x,y) = 1\ \forall y\ref{?} \in A_x.$$
Будем считать, что соответствующий алгоритм $A\in\BPP$ 
имеет вероятность ошибки $\frac{1}{2^n}$. 
Обозначим через $A_x$ множество <<хороших>> случайных строчек
для входа $x\in L$ (т.е. тех, что приводят к принятию $x$
алгоритмом $A$), а через $U_n$ --- множество всех случайных строчек
для входов длины $n$. 
Покажем, что полиномиальным количеством $k$ копий
$A_x$ мы можем покрыть $U_n$, а именно, докажем, что
что 
\begin{equation}\label{eq:cover}
\exists \{t_i\}_{i=1}^k \ \forall r\in U_n \ \bigvee_{i=1}^{k}(r\in A_x \oplus t_i).
\end{equation}
(Заметим, что для $x\notin L$ так покрыть $U_n$ нельзя из мощностных соображений.) 
Этого достаточно, так как мы доказывали, что именно в такой форме
представляется задача из $\SigmaP{2}$;
чтобы убедиться, что внутреннюю дизъюнкцию можно проверить
за полиномиальное время, заметим, что в ней лишь полиномиальное количество
формул, а проверка $r\in A_x\oplus t_i$ может
быть произведена за полиномиальное время (она эквивалентна $r\oplus t_i\in A_x$ ---
просто дадим нашему алгоритму из $\BPP$ строчку $r\oplus t_i$ случайных чисел).
Если высказывание~\ref{eq:cover} неверно, очевидно, что $x\notin L$.

Ясно, что для доказательства того, что $x\in L \Rightarrow (\ref{eq:cover})$
достаточно показать,
что для $k$ строчек $t_i$, взятых из $U_n$ случайно и 
независимо друг от друга, справедливо
$$
P\{\neg( \forall r\in U\  \bigvee_{i=1}^{k}(r\in A_x \oplus t_i))\} <1.
$$
Докажем это: 
$$P\{\neg( \forall r\in U\  \bigvee_{i=1}^{k}(r\in A_x \oplus t_i))\}  = 
P\{ \exists  r\in U\  \bigwedge_{i=1}^{k}(r\not\in A_x \oplus t_i)\} \leq $$
$$ \leq \sum_{r\in U}P\{\bigwedge_{i=1}^{k}(r\not\in A_x \oplus t_i)\}  = 
\sum_{r\in U}\prod_{i=1}^{k} P\{r\not\in A_x \oplus t_i\} 
\leq {\frac{1}{2^{nk}}}2^{p(n)}.$$ Последнее неравенство верно, так как $|U| = 2^{p(n)}$, где $p(n)=\poly(n)$ --- длина случайной строки, которой пользуется наш алгоритм из
$\BPP$; а предпоследнее равенство верно, так как выбор $t_i$ независим. Взяв $k$, равное $p(n)$, получим требуемое.
\end{proof}

\begin{remark}
Понятно, что $\BPP \subseteq \SigmaP{2} \cap \PiP{2}$, так как $\BPP = \co\BPP$. 
\end{remark}

\begin{remark}
На самом деле, можно доказать, что $\BPP \subseteq \ZPP^{\NP}$.
\end{remark}

\end{document}
