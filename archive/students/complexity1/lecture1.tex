\documentclass[12pt,fleqn,a4paper]{book}
% 
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{epsfig}
%
% Common customization:
%
\input defs
%
% The document
%
\newcommand{\sNP}{\class{\widetilde{NP}}}
\newcommand{\sP}{\class{\widetilde{P}}}
%
\begin{document}
\selectlanguage{russian}
%
% Lecture title
%
\lecture{1}{Задачи поиска; классы $\sP$ и $\sNP$; свед\'ения;
$\sNP$-полные задачи}{В. Моргенштерн}

\section{Задачи поиска.}
Базовым понятием теории сложности является понятие вычислительной задачи,
которую мы решаем с помощью той или иной вычислительной модели. Мы будем
говорить о сложности решения массовых задач, то есть множества
(однотипных) индивидуальных задач.

``Главный'' тип вычислительной задачи --- это задача поиска.
Такая (индивидуальная) задача состоит из условия и множества решений
(из которых требуется найти любое); более формально, это множество пар
вида (условие, решение). Массовой задаче соответствует
предикат, определяющий по условию и решению, что решение удовлетворяет
условию. Условие подается на вход вычислительному устройству, и мы ожидаем,
что это устройство выдаст решение, удовлетворяющее этому условию
(или сообщит, что решения не существует).

Итак, массовая задача --- это бинарное отношение на строках.
Для отношения $R$ мы 
будем также обозначать $R$ его характеристическую функцию 
и писать не только $(x,y)\in R$, но и просто $R(x,y)$.

Разумно предполагать, что 
мы умеем быстро проверять, что найденное решение --
правильное, т.е. упомянутый предикат можно быстро вычислить.
В первую очередь мы займемся именно такими вычислительными задачами.

\begin{example}
$\textbf{FACTOR}=\{\ (n,d)\ |\ d,n\in\mathbb{N},\ n\vdots d,\ 1<d<n\ \}$ --- задача
о нахождении нетривиального делителя.
\end{example}

\section{Классы $\sP$ и $\sNP$.}
Рассмотрим конечный алфавит $\Sigma$. В дальнейшем $\Sigma^*$
обозначает множество всех конечных строк в алфавите $\Sigma$,
$|x|$ обозначает длину строки $x$.

\begin{definition}
Бинарное отношение $R\subseteq \Sigma^*\times\Sigma^*$ называется
полиномиально ограниченным, если существует полином $p$, такой,
что $\forall(x,y)\in R\ (|y|\le p(|x|))$.
\end{definition}

\begin{definition}
Бинарное отношение $R\subseteq \Sigma^*\times\Sigma^*$ называется
полиномиально проверяемым, если существует полином $q$, такой, что
для любой пары $(x,y)\in\Sigma^*\times\Sigma^*$ можно проверить за время
$q(|(x,y)|)$, принадлежит ли $(x,y)$ отношению $R$ или нет.
\end{definition}

Важно, что в обоих определениях полиномы не зависят от конкретной
пары $(x,y)$. 

% \begin{definition}
% Бинарное отношение $R\subseteq \Sigma^*\times\Sigma^*$ называется
% полиномиально доказуемым, если существует полином $q$, такой, что
% для любой пары $(x,y)\in\Sigma^*\times\Sigma^*$ можно за время
% $q(|(x,y)|)$ дать такой ответ $a\in\{0,1\}$, что
% \begin{itemize}
% \item если $a=0$, то $(x,y)\notin R$;
% \item если $a=1$, то $\exists y'\ (x,y')\in R$.
% \end{itemize}
% \end{definition}

\begin{definition}
$\sNP$ --- класс задач поиска, задаваемых полиномиально ограниченными
полиномиально проверяемыми бинарными отношениями.
\end{definition}

\begin{definition}
$\sP$ --- класс задач поиска из $\sNP$, разрешимых за полиномиальное время,
т.е. задаваемых отношениями $R$, такими, что
$\forall x\in\Sigma^*$ за
полиномиальное время можно найти $y\in\Sigma^*:(x,y)\in R$.
\end{definition}

\begin{remark}
Заметим, что задача поиска, разрешимая за полиномиальное время,
может не принадлежать $\sP$: возьмем просто вычислимую функцию
и добавим к ней в качестве ``побочных'' решений произвольные.
% Обычно в теории сложности используются полиномиально проверяемые
% (а не доказуемые) отношения. Для изучаемых в дальнейшем классов \emph{языков}
% это не имеет значения. Для изучаемых же в этой главе задач \emph{поиска}
% мы используем полиномиально доказуемые отношения, чтобы обеспечить
% $\sP\subseteq\sNP$.
\end{remark}

\centerline{\Large\itshape
\fbox{Ключевой вопрос теории сложности: $\sP\vs\sNP$.}
}%\bigskip

\section{Свед\'ения.}
Одним из базовых понятий теории сложности является понятие свед\'ения.
Если мы умеем сводить задачу $D_1$ к задаче $D_2$, значит,
из любого эффективного алгоритма для задачи $D_2$
можно будет сделать эффективный алгоритм для задачи $D_1$.
Понятие свед\'ения (соответственно, ``эффективности'') здесь
может быть разным.

Для задач поиска два основных св\'едения таковы.

\begin{definition}
Пусть есть два бинарных отношения 
$R_1\subseteq\Sigma^*\times\Sigma^*$ и 
$R_2\subseteq\Delta^*\times\Delta^*$.
Свед\'ение $R_1$ к $R_2$ \emph{по Левину} состоит из трех функций $f$, $g$ и $h$, 
вычислимых за полиномиальное время\footnote{На самом деле достаточно
предполагать, что $f$ и $h$ вычислимы за полиномиальное время,
а $g$ просто существует. Однако, в исходной статье Левина формулировка
была именно такая --- более сильная (и определения, и соответствующих
утверждений).} и удовлетворяющих следующим условиям:
%обозначать $R_1\hookrightarrow R_2$, если

\begin{itemize}
\item $R_1(x_1,y_1) \Leftrightarrow R_2(f(x_1),g(x_1,y_1))$,
\item $R_1(x_1,h(f(x_1),y_2)) \Leftrightarrow R_2(f(x_1),y_2)$.
\end{itemize}

Первое условие говорит о том, что если $R_1$-задача $x_1$ имеет решение,
то и $R_2$-задача $f(x_1)$ имеет решение. Второе условие позволяет превратить
решение этой $R_2$-задачи в решение исходной $R_1$-задачи.
\end{definition}

\begin{definition}
Свед\'ение $R_1$ к $R_2$ \emph{по Куку} (оно же по Тьюрингу) --- это
полиномиальный по времени алгоритм, решающий задачу $R_1$ при условии,
что функция, находящая решение задачи $R_2$, ему дана ``как оракул'',
т.е. обращение к ней занимает всего один шаг.
%оракульная детерминированная полиномиальная по времени машина Тьюринга,
%которая решает задачу $R_1$,
%если в качестве оракула ей дана функция $h$, решающая задачу $R_2$.
%(Вычисление функции $h$ происходит за один шаг.)
\end{definition}

%Для каждого отношения $R$ 
%можно определить соответствующий язык --- множество 
%тех условий, для которых существуют решения:
%$\{x | \exists y\ R(x,y)\}$.
%Классы языков $\P$ и $\NP$ состоят из языков, соответствующих
%отношениям из $\sP$ и $\sNP$ соответственно.
\begin{remark}
Всякое свед\'ение по Левину является свед\'ением 
по Куку.
\end{remark}

%Следует заметить, что есть и другие определения свед\'ения, но
%работая в классе $\widetilde{\bf{NP}}$ удобно использовать именно
%это.

%Ясно что класс $\widetilde{\bf{P}}$ содержится в классе
%$\widetilde{\bf{NP}}$. Никто не знает, равны ли эти классы, хотя
%скорее всего они не равны. Мы хотели бы теперь понять в чем
%сложность класса $\widetilde{\bf{NP}}$. 

\section{$\sNP$-трудные и $\sNP$-полные задачи.}
Мы сейчас определим класс самых трудных задач в $\sNP$. 
Решив за полиномиальное время хотя бы одну задачу из этого класса мы
автоматически получим решение и для всех остальных задач. 

\begin{definition}
Задача поиска $C$ называется $\sNP$-трудной, если любая
другая задача $R\in\sNP$ сводится по Левину к $C$.
\end{definition}
\begin{remark}
Естественно, понятие трудности для какого-либо класса зависит
от свед\'ений, которые мы используем. Следует явно упоминать
выбранное понятие свед\'ения, когда это важно. Пока это не
для нас не слишком важно; утверждение об $\sNP$-трудности 
некоторой задачи по Левину является более сильным, и его-то
мы в дальнейшем и докажем.
\end{remark}

\begin{definition}
Задача $C$ называется $\sNP$-полной, если она
$\sNP$-трудная и принадлежит $\sNP$.
\end{definition}

\begin{remark}
Из определения ясно, что все $\sNP$-полные задачи
сводятся друг к другу.
\end{remark}

\begin{remark}
Ясно, так же, что $\sP=\sNP$ тогда и только тогда, когда
в $\sP$ имеется $\sNP$-полная задача.
\end{remark}

%Вопрос о существовании $\widetilde{\bf{NP}}$-полных задач решается
%очевидно. 
%\newcommand\hdef{#1}[\emph{#1}]
\begin{definition}[отступление --- (детерминированная) машина Тьюринга]
\small
\hdef{Детерминированная машина Тьюринга (ДМТ)} отвечает интуитивному понятию
вычислимости на машине с бесконечной памятью, доступ к которой осуществляется
шаг за шагом (бесконечно длинная полка с книгами). Она имеет 
\begin{itemize}
\item
несколько \hdef{лент},
т.е. массивов, бесконечных в одну сторону;
\item
конечный \hdef{алфавит}, т.е. множество символов,
которые могут быть записаны в клетках лент
(в том числе специальные символы ``\hdef{начало ленты}'',
записанные в начале каждой из лент, и ``\hdef{пробел}'',
которыми заполнены все неиспользованные клетки лент);
\item
читающие/пишущие \hdef{головки}, по одной для каждой ленты,
каждая из которых умеет последовательно двигаться по своей ленте,
читая или записывая символы на ленту (в один момент времени
головка находится у одной позиции ленты --- с символом именно в этой
клетке она и может работать);
\item
конечное множество \hdef{состояний},
в котором выделены \hdef{начальное}, \hdef{принимающее}
и \hdef{отвергающее} состояния;
\item
и самое главное --- \hdef{управляющее устройство} (\hdef{программу}),
содержащее инструкции, \emph{однозначно} определяющие,
как по состоянию и символам, обозреваемым
головками, решить, в какое состояние перейти, какие символы записать,
куда сдвинуть головки (на одну позицию влево, вправо или никуда).
\end{itemize}

\begin{center}
\psfig{file=lecture1pic.eps, width=8cm}
\end{center}

Вычисление на \hdef{детерминированной машине Тьюринга} похоже на вычисление
на любом реальном вычислительном устройстве: 
\begin{itemize}
\item
в начале работы все ленты пусты, за исключением одной, на которой
написано задание (\hdef{входное слово}), 
машина находится в начальном состоянии, все головки
находятся в крайней левой позиции;
\item
шаг за шагом выполняются
инструкции программы;
\item
если машина попадает в конечное (принимающее либо отвергающее) состояние,
она заканчивает свою работу.
\end{itemize}

ДМТ \hdef{принимает} входное слово, если она
заканчивает свою работу в принимающем состоянии;
она \hdef{отвергает} его, если заканчивает работу в отвергающем состоянии.
Если для всех входных слов ДМТ заканчивает работу, то
множество принимаемых ей слов называется \hdef{языком, принимаемым}
этой машиной. Иначе говоря, машина \hdef{решает задачу} принадлежности
данному языку.

ДМТ может также \hdef{вычислять какую-нибудь функцию}. 
Значением этой функции на данном входном слове 
будем считать содержимое первой ленты
после достижения конечного состояния.
\end{definition}

В некотором роде самой естественной $\sNP$-полной задачей является задача об
ограниченной остановке. Прежде чем сформулировать эту задачу,
заметим, что любую машину Тьюринга $M$ (т.е. ее функцию перехода)
можно закодировать строкой в некотором алфавите. 
%(Фактически это означает, что можно написать программу,
%которая повторяет действия машины.)
Теперь мы может сформулировать задачу.
\begin{problem}[об ограниченной остановке]
Бинарное отношение $R$ этой задачи вводится следующим образом:
$(\langle M, x_1, 1^t\rangle, x_2)\in R $ тогда и только
тогда, когда $M$ на входе $\langle x_1,x_2\rangle$ останавливается
не более чем через $t$ шагов в принимающем состоянии.
\end{problem}

\begin{theorem}
Задача об ограниченной остановке --- $\sNP$-полна.
\end{theorem}
\begin{proof}
{\bfseries $\sNP$-трудность.}
Сведем произвольную задачу $R\in\sNP$ к задаче об ограниченной остановке.
Условием будет $\langle M, x, \mathtt{1}^t\rangle$, где $M$ --- проверяющий
алгоритм, $x$ --- условие задачи $R$, $t$ --- время, за которое $M$
должен успеть проверить (самое короткое) решение задачи $R$
(очевидно, оно ограничено полиномом от длины $x$).
Ясное дело, решением будет как раз решение задачи $R$.

{\bfseries Принадлежность $\sNP$.}
Можно доказать,
что существует так называемый универсальный алгоритм, который
получает на вход пару $\langle M, x \rangle$ и, если $M$
останавливается на $x$, тоже останавливается и выдает
то же самое значение, что и $M$ на $x$, 
причем время его работы полиномиально
зависит от времени работы $M$ на $x$. 
Моделируя таким образом
машину $M$ из определения задачи об ограниченной остановке,
мы сможем за полиномиальное %от $t$ (а значит, и от длины входа\ref{?}) 
время проверить решение. 
\end{proof}

\begin{theorem}[Кук-Левин]\label{th:sat}
$\widetilde{\lang{SAT}}$ 
(задача нахождения выполняющего набора для булевой формулы в КНФ) --- 
$\sNP$-полна.
\end{theorem}
\begin{proof}
Подойдет любое известное доказательство, см., например,
книгу Гэри и Джонсона.
\end{proof}

\section{Задачи распознавания.}
Большинство задач классической теории сложности формулируются как
задачи распознавания, т.е. принадлежности языку.
В частности, классы языков $\P$ и $\NP$ определяются следующим образом.

\begin{definition}
$L\in\NP$, если существует $R\in \sNP$, такое, что 
$x\in L \Leftrightarrow \exists y R(x,y)$.
\end{definition}

\begin{definition}
$L\in\P$, если для любой строки $x$ вопрос о принадлежности 
ее языку $L$ может быть решен за полиномиальное время от ее длины.
\end{definition}

На первый взгляд, $\NP$-задачи проще $\sNP$-задач.
Тем не менее, верна следующая теорема.

\begin{theorem}
Пусть $R\in\sNP$, а $L$ --- соответствующий ей язык из $\NP$.
Если $L$ --- $\NP$-труден\footnote{Полные и трудные языки
определяются аналогично полным и трудным задачам поиска.}, 
то $R$ сводится к $L$ по Куку.
\end{theorem}
\begin{proof}
Сведем $R$ к $\widetilde{\lang{SAT}}$ (по теореме~\ref{th:sat}).

Ее, в свою очередь, к $\lang{SAT}$:
$$
F[x_1\leftarrow a_1,\vec{y}\leftarrow\vec{b}]\in\lang{SAT} 
\Leftrightarrow 
F[x_1\leftarrow a_1]\in\lang{SAT}
$$
(здесь $\vec{y}$ --- вектор $(x_2,\ldots,x_n)$ всех переменных, кроме $x_1$),
так что проверим\footnote{$F[x_1\leftarrow a_1]$ является формулой в КНФ:
все константы $0$ и $1$, появившиеся после подстановки, могут быть устранены
очевидным образом.}
$F[x_1\leftarrow 0]\in\lang{SAT}$ и $F[x_1\leftarrow 1]\in\lang{SAT}$ и присвоим
значение переменной $x_1$ соответственно.
Узнав значение переменной $x_1$, будем узнавать остальные,
применив ту же процедуру к переменной $x_1$ в формуле $F[x_1\leftarrow a_1]$,
\Retc

$\lang{SAT}$ же сводится в $L$ по условию теоремы.
\end{proof}

Наряду со сведением по Куку, для языков можно использовать
его более простой частный случай --- сведение по Карпу.

\begin{definition}
Пусть есть два языка $L_1$ и $L_2$.
Свед\'ение $L_1$ к $L_2$ \emph{по Карпу} 
(many-one reduction) --- 
это функция $f$, вычислимая за полиномиальное время,
такая, что $\forall x\ (x\in L_1 \Leftrightarrow f(x)\in L_2)$.
\end{definition}

\begin{remark}
Всякое свед\'ение по Карпу является свед\'ением по Куку.
Всякое свед\'ение по Левину является свед\'ением языков по Карпу
и задач поиска --- по Куку.
\end{remark}

\end{document}

