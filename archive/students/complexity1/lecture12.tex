\documentclass[12pt,fleqn,a4paper]{book}
% 
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
%
% Common customization:
%
\input defs

\newcommand{\MA}{\class{MA}}
\newcommand{\AM}{\class{AM}}
\newcommand{\Size}{\class{Size}}
\newcommand{\Inter}{\SigmaP{2} \cap \PiP{2}}
\newcommand{\PsharpP}{\P^{\sharp\P}}
\newcommand{\PpP}{\P^{\PP}}
\newcommand{\RingK}{\mathbb{K}}
\newcommand{\perm}{\mathop{\mathrm{perm}}}

%
% The document
%
\begin{document}
\selectlanguage{russian}
%
% Lecture title
%
\lecture{12}{Схемная сложность классов полиномиальной иерархии и $\PP$}{Р. Мясников, К. Первышев}
%
% The lecture
%
Доказать $\NP\nsubseteq\Ppoly$ не проще, чем $\NP\neq\P$. Более того, до сих пор не удается доказать, что языки из $\NP$ не могут быть распознаны булевыми схем размера $O(n^2)$. Тем не менее, для некоторых более широких классов это можно доказать. Этим мы и займемся. 

\begin{definition}
Обозначим $\Size[f(n)]$ класс языков, распознаваемых булевыми схемами
размера $O(f(n))$.
\end{definition}

\section{Схемная сложность классов полиномиальной иерархии}

\begin{lemma}
$\SigmaP{4} \nsubseteq \Size[n^k]$ для любого $k$.
\end{lemma}

\begin{proof}
Количество схем размера $n^k$ меньше количества функций, зависящих только от первых $c \cdot k \cdot \log n$ битов. Значит, существует подобная функция, не имеющая представления в виде булевой схемы размера $n^k$. Покажем, что одна из подобных функций лежит в $\SigmaP{4}$.

Заметим, что так как любая из рассматриваемых функций зависит от $c \cdot k \cdot \log n$ битов, то она может быть закодирована полиномиальным числом битов (например, в виде таблицы истинности). Невычислимость функции $f$ с помощью булевой схемы размера $n^k$ на входах длины $n$ может быть записана следующим образом: $\forall$ схемы $c$ (размера $n^k$) $\exists$ вход $x$ (длины $n$), для которого $f(x) \neq c(x)$.
 
Введем на множестве рассматриваемых функций какой-нибудь просто вычислимый порядок (например, лексикографический). Теперь рассмотрим наименьшую по этому порядку невычислимую с помощью булевых схем размера $n^k$ функцию $f$ и определим язык $L$ как множество слов, на которых эта функция принимает значение $1$. Говоря строго,
	\begin{equation*}
	y \in L \iff \exists f: 
		\begin{cases}
		\forall c \exists x: f(x) \neq c(x) \\
		\forall f': (\forall c \exists x: f'(x) \neq c(x)) \implies f \le f' \\
		f(y) = 1
		\end{cases}
	\end{equation*}
Это выражение можно переписать как
	\begin{multline*}
	y \in L \iff 
	\exists f ~ \forall c \forall f' ~ \exists x \exists c' ~ \forall x' :\\
	f(x) \neq c(x)
	\wedge ((f \le f') \vee f'(x') = c'(x'))
	\wedge f(y) = 1.
	\end{multline*}
Мы описали язык $L$ из $\SigmaP{4}$, который не может быть описан схемой размера $n^k$. Но нас интересует такой язык, который не может быить описан схемами размера $O(n^k)$.
 
Возьмём схему $c$ размера $C \cdot n^{k-1}$. Для некоторого $n_0$ верно, что $C \cdot n_0^{k-1} < n_0^k$. Очевидно, существует вход $x$ длины $n_0$, на котором $c(x)$ неверно решает задачу о принадлежности $L$. Следовательно, $L\notin\Size[n^{k-1}]$.
\end{proof}

\begin{remark}
Из этого не следует, что $\SigmaP{4} \nsubseteq \Ppoly$.
\end{remark}

\begin{corollary}
$\PH \nsubseteq \Size[n^k]$ для любого $k$.
\end{corollary}

Теперь мы в состоянии подобраться ближе к $\NP$, доказав более сильное утверждение:

\begin{theorem}
$\Inter \nsubseteq \Size[n^k] $ для любого $k$.
\end{theorem}

\begin{proof}
Предположим противное: пусть $\Inter \subseteq \Size[n^{k}]$ для некоторого $k$. Тогда класс $\NP$ принимается схемами полиномиального размера. Это влечёт коллапс полиномиальной иерархии до $\Inter$ (см. лекцию~6). Тем самым, $\PH = \Inter \subseteq \Size[n^{k}]$. Противоречие.
\end{proof}

\begin{remark}
Аналогичным образом можно доказать более сильные утверждения. На самом деле, наличие схем полиномиального размера для класса $\NP$ влечёт коллапс полиномиальной иерархии не только до $\Inter$, но и до $\ZPP^{\NP}$, и даже ещё сильнее. Следовательно, $\ZPP^{\NP} \nsubseteq \Size[n^k]$ для любого $k$.
\end{remark}

\section{Схемная сложность $\PP$}
От классов полиномиальной иерархии перейдём к классу $\PP$. Напомним, что в одной из предыдущих лекций было доказано следующее: 
	\begin{equation*}
	\boxed{\PH \subseteq \PpP ~\text{(теорема Тода)}}
	\end{equation*}
В то же время, $\PpP = \PsharpP$.\\

Из теоремы Шамира мы знаем, что $\PSPACE$ имеет интерактивный протокол с prover'ом из $\PSPACE$. Покажем следующее:

\begin{theorem}
$\PsharpP$ имеет интерактивный протокол с prover'ом из $\PsharpP$.
\end{theorem}	

\begin{proof}
Примем сторону verifier'а и опишем интерактивный протокол. Для проверки принадлежности слова $x$ языку $L$, распознаваемому машиной, обладающей оракулом из $\sharp\P$ и работающей полиномиальное время $q(n)$, мы нуждается в содействии prover'a лишь для вычисления перманента\footnote{Перманент матрицы $A=(a_{i,j})_{1\le i,j\le n}$ определяется как $\perm A=\sum_{i\in S_n}\prod_{i=1}^n{a_{i,\sigma(i)}}$, где $S_n$ --- группа всех перестановок $1..n$.} матрицы.

Все вычисления производятся над конечным кольцом $\RingK$, размер которого выберем позднее. Пару $(A,b)$, составленную из матрицы $A$ и скаляра $b$, будем называть \itshape хорошей \upshape, или \itshape корректной \upshape, если $\perm A = b$, и \itshape плохой \upshape в противном случае. Ответив скаляром $b$ на очередной вопрос о перманенте некоторой матрицы $A$, prover будет пытаться нас убедить в том, что пара $(A,b)$ хорошая.

Разложим перманент матрицы $A = (a_{i,j})_{1 \le i,j \le n}$ по первой строке и получим $\perm A = \sum_{j=1}^n a_{1,j} \cdot \perm A_j$. Попросим prover для каждого $j$ прислать $b_j = \perm A_j$. Проверим равенство $b = \sum_{j=1}^n a_{1,j} \cdot b_j$. Это обеспечит наличие хотя бы одной плохой пары среди пар $(A_j, b_j)$ в случае, если пара $(A,b)$ была плохой.

Сформируем набор $U = \{ (A_j, b_j) \}_{j=1}^n$. Пока в наборе $U$ содержится хотя бы два элемента, будем повторять следующую операцию. Возьмём из $U$ две любые пары $(D,d)$ и $(E,e)$. Сформируем матрицу $C(x) = x \cdot D + (1-x) \cdot E$. Заметим, что её перманент является многочленом $p(x)$, степень которого не больше $n$. Попросим prover прислать коэффициенты этого многочлена. Используя интерполяцию, хороший prover из класса $\PsharpP$ это сделать в состоянии.
 
Итак, prover прислал коэффициенты некоторого многочлена $\tilde p$. Проверим, что $\tilde p(0) = e$ и $\tilde p(1) = d$. Это влечёт отличие многочлена $\tilde p$ от многочлена $p = \perm C(x)$ в случае, если хотя бы одна из пар $(D,d)$ и $(E,e)$ была плохой. Выберем случайным образом элемент $r$ нашего кольца $\RingK$, и заменим эти две пары в наборе $U$ на одну пару $(C(r),\tilde p(r))$. При условии $p \neq \tilde p$, $r$ является корнем ненулевого полинома $p - \tilde p$, степень которого не более $n$, с вероятностью не более $\frac{n}{|\RingK|}$. Тем самым, если набор $U$ содержал плохую пару, то и после описанного изменения с вероятностью как минимум $1 - \frac{n}{|\RingK|}$ в нём присутствует хотя бы одна плохая пара. 

После повторения этой операции не более $n$ раз, набор $U$ будет состоять из одной-единственной пары $(A',b')$. Если исходная пара $(A,b)$ была плохой, то и $(A',b')$ плоха с вероятностью не менее $1 - \frac{n^2}{|\RingK|}$. Причём размер матрицы $A'$ на единицу меньше размера исходной матрицы $A$. Таким образом задачу проверки корректности пары с матрицей размера $n$ мы свели к аналогичной задаче с матрицей размера $n-1$. И, тем самым, мы умеем проверять перманент матрицы $A$ размера $n$ с вероятностью ошибки не более $\frac{n^3}{|\RingK|}$.

В ходе работы prover'а количество запросов и размеры матриц, для которых вычисляется перманент, не превосходят $q(n)$. И вероятность, с которой verifier поверит обманщику, сказав ``да'' на $x \not \in L$, не превышает $\frac{q(n)^3}{|\RingK|}$. Отсюда легко определить подходящий размер кольца $\RingK$. В то же время, хороший prover всегда сможет убедить verifier'a.
\end{proof}
	
Определим протоколы типа Мерлин-Артур. Как водится, Мерлин всемогущ, а Артур справедлив:

\begin{definition}[$\MA$, $\MA_2$ --- протоколы Мерлин-Артур]
Язык $L \in \MA$, если существуют такие полиномы $p$ и $q$, а также машина $M$, работающая на всех входах полиномиальное время, что  для всех $x$ верно следующее:
	\begin{gather*}
	x \in L \implies \exists y\in\{0,1\}^{p(|x|)} : \Pr_{z\in\{0,1\}^{q(|x|)}} \{M(x,y,z) = 1\} > 3/4, \\
	x \notin L \implies \forall y\in\{0,1\}^{p(|x|)} : \Pr_{z\in\{0,1\}^{q(|x|)}} \{M(x,y,z) = 1\} < 1/4.
	\end{gather*}
%где запись $y^{p(|x|)}$ означает, что слово $y \in \{0,1\}^*$ имеет длину $p(|x|)$.
\end{definition}

Говоря неформально, Мерлин присылает доказательство, а Артур, подбросив несколько раз монетку, проверяет его.

Можно показать (см. следующую лекцию), что можно требовать,
чтобы при $x\in L$ вероятность ошибки была равна нулю.
Этот (несимметричный) вариант будем обозначать $\MA$,
а симметричный --- $\MA_2$.
\pagebreak
\begin{remark}
\phantom{.}\hfill

\phantom{WWW}
\hspace{5mm}
\small
\begin{minipage}{12cm}
Аналогично можно определить и протоколы типа Артур-Мерлин, в начале которого Артур сообщает Мерлину исходы подбрасывания монеток.

\begin{definition}[$\AM$ --- протоколы Артур-Мерлин]
Язык $L \in \AM$, если существуют полиномы $p$ и $q$, а также машина $M$, работающая на всех входах полиномиальное время, что  для всех $x$ верно следующее:
	\begin{gather*}
	x \in L \implies \Pr_{z\in\{0,1\}^{q(|x|)}} \{\exists y\in\{0,1\}^{p(|x|)} : M(x,y,z) = 1\} > 3/4 \\
	x \notin L \implies \Pr_{z\in\{0,1\}^{q(|x|)}} \{\exists y\in\{0,1\}^{p(|x|)} : M(x,y,z) = 1\} < 1/4
	\end{gather*}
\end{definition}

\begin{exercise}
$\MA_2 \subseteq \AM$.
\end{exercise}
\begin{exercise}
В предположении, что $\NP \subseteq \Ppoly$, имеет место $\MA = \AM$.
\end{exercise}
\end{minipage}
\end{remark}
\vspace{3mm}

\begin{lemma}
В предположении, что $\PP \subseteq \Ppoly$, имеет место $\PpP \subseteq \MA$.
\end{lemma}

\begin{proof}
Поскольку каждая машина из $\PpP$ задаёт вопросы к оракулу из $\PP$ не более чем полиномиальной длины, имеем $\PsharpP = \PpP \subseteq \Ppoly$, где подсказками являются наборы схем, вычисляющие ответы оракула из класса $\PP$ на входах длины не более $\poly(n)$. 

Возьмём интерактивный протокол для класса $\PsharpP$ с prover'ом из $\PsharpP$. Потребуем, чтобы prover не помнил истории диалога с verifier'ом, но verifier при каждом своём обращении к prover'у отсылал бы эту историю (имеющую полиномиальную длину). Ясно, что при наложении таких требований хороший prover будет по-прежнему в состоянии доказать принадлежность слова языку, а плохой prover будет всё так же пойман с большой вероятностью. Тем самым, хороший prover превращается в обычную машину из $\PsharpP$.

Теперь позовём Артура с Мерлином. Артур будет моделировать verifier, но вместо обращений к prover'у Артур будет использовать схемы, присланные Мерлином в самом начале выполнения протокола. Эти схемы будут полноценным заменителем prover'а, поскольку запросы verifier'а имеют длину $\poly(n)$, а $\PsharpP \subseteq \Ppoly$. 
%Именно здесь мы используем забывчивость prover'а, которая превращает его из интерактивной машины в обычного представителя класса $\PsharpP$.
Таким образом, $\PpP = \PsharpP \subseteq \MA$.
\end{proof}


Перейдём непосредственно к интересующему нас утверждению:

\begin{theorem}
$\PP \nsubseteq \Size[n^k]$ для любого $k$.
\end{theorem}

\begin{proof}
В предположении, что для некоторого $k$ выполняется $\PP \subseteq \Size[n^k]$, имеем: 
$$ \PH \subseteq \PpP \subseteq \MA_2 \subseteq \PP, $$
(последнее включение $\MA_2 \subseteq \PP$ --- техническая лемма~\ref{lem:mapp}),
откуда в силу $\PH \nsubseteq \Size[n^k]$ имеем $\PP \nsubseteq \Size[n^k]$.
\end{proof}

\begin{lemma}\label{lem:mapp}
$\MA_2 \subseteq \PP$.
\end{lemma}

\begin{proof}
Пусть $L \in \MA_2$. Чтобы уменьшить вероятность ошибки Артура, выполним его процедуру над одним и тем же доказательством Мерлина несколько раз, каждый раз подкидывая монетки заново. Выберем ответ, встречающийся наибольшее число раз, и воспользуемся неравенством Чернова подобно тому, как это делалось для $\BPP$.

Таким образом, имеются такие полиномы $p$ и $q$, а также машина $M$, работающая на всех входах полиномиальное время, что для всех $x$ верно следующее:
	\begin{gather*}
	x \in L \implies \exists y\in\{0,1\}^{p(|x|)} : \Pr_{z\in\{0,1\}^{q(|x|)}} \{M(x,y,z) = 1\} > 1-4^{-p(|x|)} \\
	x \notin L \implies \forall y\in\{0,1\}^{p(|x|)} : \Pr_{z\in\{0,1\}^{q(|x|)}} \{M(x,y,z) = 1\} < 4^{-p(|x|)}
	\end{gather*}
Будем выбирать $y$ случайным образом (вместо того, чтобы спрашивать его у Мерлина) --- тем самым, мы рассматриваем последовательности подбрасываний монеток $(y,z)\in\{0,1\}^{p(|x|)+q(|x|)}$. Тогда
	\begin{gather*}
	x \in L \implies \Pr_{(y,z)} \{M(x,y,z) = 1\} > 2^{-p(|x|)} \cdot (1-4^{-p(|x|)}) > 4^{-p(|x|)} \\
	x \notin L \implies \Pr_{(y,z)} \{M(x,y,z) = 1\} < 4^{-p(|x|)}
	\end{gather*}
Заметим, что порог $1/2$ в определении класса $\PP$ может быть успешно заменён на любую функцию вида $a(x) \cdot 2^{-s(|x|)}$, где $s$ --- полином, а $a$ --- функция, вычислимая за полиномиальное время. В частности, на $4^{-p(|x|)}$.
\end{proof}

\end{document}
