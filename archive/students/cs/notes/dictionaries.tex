\documentclass[12pt,fleqn,a4paper]{book}
%
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{fullpage}
\advance\textheight by 1cm
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{url}
\usepackage{EZlist}
%
% Common customization:
%
\pagestyle{headings}
\newtheorem{theorem}{Теорема}[chapter]
\newtheorem{lemma}{Лемма}[chapter]
\newtheorem{proposition}{Утверждение}[chapter]
\newtheorem{fact}{Факт}[chapter]
\theoremstyle{definition}
\newtheorem{problem}{Задача}[chapter]
\newtheorem{exercise}{Упражнение}[chapter]
\newtheorem{example}{Пример}[chapter]
\newtheorem{definition}{Определение}[chapter]
\newtheorem{remark}{Замечание}[chapter]
\newtheorem{algorithm}{Алгоритм}[chapter]
\newcommand{\marginnote}[1]{\marginpar{\raggedright\ \fbox{\small #1}}}
\def\gap{\medskip\centerline{\fbox{\Huge\bfseries{ПРОБЕЛ В КОНСПЕКТЕ.}}}\medskip}
\advance\headheight by 7pt
\def\headsep{15mm}
\newcommand{\lecture}[2]{%
\def\rightmark{\fbox{\parbox{125mm}{\lecturername: \coursetitle%
\hfil\phantom{.}}}}
\def\leftmark{\fbox{\parbox{125mm}{Лекция {#1}. {#2}%
\hfil\phantom{.}}}}
\renewcommand\chaptername{Лекция}\renewcommand\thechapter{#1}\chapter{{#2}}
\thispagestyle{headings}}
%
% Things to customize for the course are here:
%
\newcommand\lecturername{Э. А. Гирш}
\newcommand\coursetitle{``Информатика'' (обрывки разных конспектов)}
%
% Now, this particular lecture definitions:
%
%
% The document
%
\begin{document}
\selectlanguage{russian}
\sloppy
%
% Lecture title
%
\lecture{D}{Словари}
%
% The lecture
%
\section{Словари как абстрактная структура данных}
Словарь --- структура данных, имеющая операции
\begin{itemize}
\item INSERT;
\item DELETE;
\item FIND.
\end{itemize}
Мы изучим один из вариантов реализации словаря --- дерево поиска;
добиваться будем реализации операций за $O(\log(\mbox{количества элементов}))$
операций над элементами.
Конструкции таких деревьев разнообразны сами по себе.

\section{Отступление: представление деревьев в компьютере}\marginnote{5}
Будем говорить о деревьях с корнем.

Имеется много разновидностей структур данных, называемых деревьями.
Соответственно, и набор операций над деревьями может быть разным.
Поэтому \emph{представление зависит от требуемых операций}. 
%(Например, мы уже видели нетрадиционное представление двоичного дерева
%в виде массива в ситуации, когда перестановки поддеревьев и даже 
%вставка/удаление не нужны.)

Как представить двоичное дерево, ясно: элемент, соответствующий каждой
вершине, содержит хранимые данные и два указателя: на левого и правого сына;
если нужно --- указатель на родителя.
Для дерева с произвольной степенью вершин имеется несколько вариантов:
например, список сыновей (полезно указать их количество, а указатель наверх
хранить в каждом из них).

\begin{remark}
Динамический массив вместо списка не подойдет --- трудно вставлять!
\end{remark}

\section{Деревья поиска}
Дерево поиска --- структура данных, для которой эффективно реализуемы
операции INSERT, DELETE и FIND (поиск по ключу).
Данные, как правило, будут храниться в вершинах дерева,
но обращать внимание мы будем только на ключ --- то поле записи,
по которому ведется поиск. Ключ должен быть элементом некоторого
линейно упорядоченного множества.
Для простоты в наших примерах будем предполагать, что все ключи различны.
Даже если исходно данные не представлены в виде дерева, их может быть
полезно представить в таком виде, если они упорядочены и над ними часто
приходится выполнять указанные операции.

Свойство 
\begin{equation}\label{eq:search}
\mbox{\parbox{95mm}{
<<все элементы левого поддерева меньше ключа,
ключ больше всех элементов правого поддерева>>
}}
\end{equation}
позволяет реализовать FIND за $O(\textrm{высоты дерева})$ операций.
Если дерево <<идеально>> (высота $h$, количество вершин $2^{h+1}-1$), 
имеем $O(\log n)$ операций. Ниже мы изучим разновидности деревьев
поиска, позволяющие поддерживать себя в <<почти идеальном>> виде,
при этом ограничиваясь логарифмическим количеством операций
с элементами при реализации операций INSERT и DELETE.

\subsection{АВЛ-деревья\protect\footnote{Сокращение произошло
от фамилий авторов этой конструкции (Адельсон-Вельский и Ландис).}}\marginnote{20}

\begin{definition}
\emph{АВЛ-дерево (сбалансированное дерево)}: двоичное дерево поиска
(удовлетворяющее свойству (\ref{eq:search})),
для любой вершины которого высоты левого и правого поддеревьев
отличаются не более, чем на единицу.
\end{definition}

\begin{lemma}
Высота АВЛ-дерева составляет $O(\log n)$.
\end{lemma}
\begin{proof}
Покажем по индукции, что в АВЛ-дереве высоты $h$ имеется не менее
\[
\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^h +
\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^h -1
\qquad(=\Omega(\phi^h))
\]
вершин\footnote{Имеется в виду обозначение $\Omega$, принятое в 
(непрерывном) математическом анализе.}. Очевидно, в дереве высоты $h$
имеется не менее $G_{h-1}+G_{h-2}+1$ вершин,
где $G_i$ --- наименьшее количество вершин в АВЛ-дереве высоты $i$.
По предположению индукции
%, имеем по крайней мере
%\[
%\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^{h-1} +
%\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^{h-1} -1 +
%\]
%\[
%\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^{h-2} +
%\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^{h-2}= 
%\]
%\[
%\frac{3+\sqrt{5}}{2}\cdot\frac{5+2\sqrt{5}}{5}\left(\frac{1+\sqrt{5}}{2}\right)^{h-2} +
%\frac{3-\sqrt{5}}{2}\cdot\frac{5-2\sqrt{5}}{5}\left(\frac{1-\sqrt{5}}{2}\right)^{h-1} -1 +
%\]
%вершин.
доказательство завершается 
(NB: $(\frac{1\pm\sqrt{5}}{2})^{{}^2}=\frac{3\pm\sqrt{5}}{2}$).
\end{proof}

Следовательно, поиск элемента отнимает лишь $O(\log n)$ операций.
Покажем, что то же самое относится и к операциям INSERT и DELETE.
Для поддержания сбалансированности нам понадобится выяснять высоты поддеревьев.
Для этого будем хранить в каждой из вершин разность высот левого
и правого поддеревьев (очевидно, высота любого поддерева тогда вычисляется
за $O(\log n)$ операций --- но в большинстве случаев это даже не нужно).

\begin{description}
\item[INSERT.] Попробуем вставить вершину с ключом $i$.
Найдем место, где она должна находиться, и вставим ее туда.
Если это второй потомок какой-то вершины, то высота не изменилась, и все OK.
В противном случае, посмотрим на высоты всех (пра)родителей вершины $i$.
По ним мы сможем найти самую нижнюю из разбалансированных вершин (назовем ее $v$);
пусть $w$ --- первая вершина на пути из $v$ в $i$.

Если $i$ была вставлена во <<внешнее>> поддерево вершины $w$,
мы можем совершить следующее <<вращение>>: $w$ становится корнем,
а $v$ --- ее сыном. <<Внутреннее>> поддерево вершины $w$ становится <<внутренним>>
поддеревом вершины $v$.
\begin{verbatim}
            v                             w
           / \                           / \
          A   w              --->       v   I
             / \                       / \
            B   I (в нем i)           A   B
\end{verbatim}
Если же $i$ была вставлена во <<внутреннее>> поддерево вершины $w$,
то сначала надо произвести другое <<вращение>> поддерева с корнем $w$, 
чтобы попасть в только что рассмотренную ситуацию:
\begin{verbatim}
            v                             v
           / \                           / \
          A   w              --->       A   x
             / \                           / \
            x   C                         I   w
           / \                               / \
          I  I'                             I'  C
\end{verbatim}
Теперь правое поддерево вершины $x$ (играющей роль $w$) заведомо выше левого,
так что вершина, разбалансирующая $v$, расположена именно в правом поддереве.

\begin{remark}
Заметим, что все эти операции затрагивают только поддерево с корнем $v$!\qed
\end{remark}

\medskip
\item[DELETE.] Аналогично. Однако, заметим, что после <<вращений>> высота
всего дерева с корнем $v$ может уменьшиться. При добавлении это не мешало,
так как получалась в точности высота этого дерева до добавления, а остальные
вершины уже были сбалансированы при этом условии. При удалении же
может разбалансироваться другая вершина (выше) и операции надо будет повторить
(и$\;$т.$\;$д. --- вплоть до $O(\log n)$ раз).
\end{description}

\subsection{B-деревья} \marginnote{10}
Мотивировка: хранение базы данных на диске;
заодно с нужными данными с диска автоматически
(так работают диски) считывается сразу много других
(целый \emph{блок} ---
физическая единица информации на диске);
хорошо бы, чтобы они в дальнейшем тоже были небесполезны.

Степень вершин теперь между $t-1$ и $2t-1$ (кроме корня: его степень $\ge2$) --- 
так, чтобы запись всей вершины в точности поместилась в блок.
Соответственно, в каждой вершине хранится больше ключей.

\begin{remark}
Есть и другие варианты: например, $t$ и $2t$, соответственно.
\end{remark}

Реализация операций:
\begin{description}
\item[INSERT.]\hfill
\begin{itemize}
\item Переполненный лист или внутреннюю вершину --- 
      разделяем, средний элемент отправляем в родителя.
\item Переполненный корень разделяем, увеличивая высоту дерева.
\end{itemize}
\item[DELETE.]\hfill

Рекурсивно спускаемся по дереву, предварительно гарантируя,
что каждый раз переходим к вершине, в которой хотя бы $t$ (а не $t-1$) ключей
(корень --- отдельный случай).
\begin{itemize}
\item Если нашелся нужный ключ во внутренней вершине, меняем его с листом
      и продолжаем процесс.
\item В листе все тривиально.
\item Если можно занять у соседки --- делаем это (ключ из соседки --- в родителя,
от родителя --- в нашу следующую вершину).
\item Если нет --- занимаем у родителя (у него было целых $t$ ключей!).
\end{itemize} 
\end{description}

\subsection{B${}^+$-деревья} \marginnote{5}
Можно не хранить данные во внутренних вершинах, а повторять там ключи
из нижних уровней дерева. Тогда, объединив листья в двунаправленный список,
мы сможем быстро находить предыдущий и следующий (в смысле упорядочения) элемент.

%-----------------------------------------------------------
\end{document}

