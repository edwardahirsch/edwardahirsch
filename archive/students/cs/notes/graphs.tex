\documentclass[12pt,fleqn,a4paper]{book}
%
% Packages used:
%
\usepackage[koi8-r]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{url}
\usepackage{EZlist}
%
% Common customization:
%
\pagestyle{headings}
\newtheorem{theorem}{Теорема}[chapter]
\newtheorem{lemma}{Лемма}[chapter]
\newtheorem{proposition}{Утверждение}[chapter]
\newtheorem{fact}{Факт}[chapter]
\theoremstyle{definition}
\newtheorem{problem}{Задача}[chapter]
\newtheorem{exercise}{Упражнение}[chapter]
\newtheorem{example}{Пример}[chapter]
\newtheorem{definition}{Определение}[chapter]
\newtheorem{remark}{Замечание}[chapter]
\newtheorem{algorithm}{Алгоритм}[chapter]
\newcommand{\marginnote}[1]{\marginpar{\raggedright\ \fbox{\small #1}}}
\def\gap{\medskip\centerline{\fbox{\Huge\bfseries{ПРОБЕЛ В КОНСПЕКТЕ.}}}\medskip}
\advance\headheight by 7pt
\def\headsep{15mm}
\newcommand{\lecture}[2]{%
\def\rightmark{\fbox{\parbox{125mm}{\lecturername: \coursetitle%
\hfil\phantom{.}}}}
\def\leftmark{\fbox{\parbox{125mm}{Лекция {#1}. {#2}%
\hfil\phantom{.}}}}
\renewcommand\chaptername{Лекция}\renewcommand\thechapter{#1}\chapter{{#2}}
\thispagestyle{headings}}
%
% Things to customize for the course are here:
%
\newcommand\lecturername{Э. А. Гирш}
\newcommand\coursetitle{``Информатика'' (обрывки разных конспектов)}
%
% Now, this particular lecture definitions:
%
%
% The document
%
\begin{document}
\selectlanguage{russian}
\sloppy
%
% Lecture title
%
\lecture{G}{Алгоритмы на графах}
%
% The lecture
%
%-----------------------------------------------------------
\section{Представление графа в машине}
\begin{definition}
Ориентированный граф $G$ --- это пара конечных множеств $(V,E)$,
где $V$ называется множеством вершин, а $E\subseteq V\times V$ ---
множеством ребер (ребро $(v_1,v_2)$ можно представить себе как
стрелку из $v_1$ в $v_2$). Будем считать, что в графе нет петель,
т.е. $\forall v\ (v,v)\notin E$.

Неориентированный граф отличается от ориентированного тем, что на ребрах не указано
направление, т.е. ребра --- множества, а не
упорядоченные пары; тогда множество ребер $E\subseteq \{\{u,v\}\,|\,u,v\in V, u\neq v\}$.

Часто рассматривают графы с весами --- когда каждому ребру приписано
некоторое число, называемое весом этого ребра.
\end{definition}

Поскольку множество $V$ конечно, можно считать его элементы последовательными
натуральными числами.

Вот некоторые способы представить граф в машине (выбор конкретного
способа определяется задачей --- в каком виде граф нам задан, и алгоритмом ---
какие операции нам нужны):
\begin{itemize}
\item общий список ребер (неэффективно: трудно искать ребра из данной вершины, пути, \ldots);
\item матрица смежности:
\begin{itemize}
\item \leftskip -5mm двумерный массив: $A[i,j]=1 \Leftrightarrow (i,j)\in E$,
\item матрица с пропусками,
\item неявное задание (при помощи \emph{функции} $f$): $f(i,j)=1 \Leftrightarrow (i,j)\in E$;
\end{itemize}
\item массив (из $|V|$ элементов), в котором $A[i]$ ---
      массив/список/дерево ребер, исходящих из вершины $i$;
\item АВЛ-дерево; ключи --- вершины; можно и список ребер для каждой из них
      представить АВЛ-деревом.
\end{itemize}
\begin{remark}
Время работы алгоритмов будем выражать не через длину входа,
а через $|E|$, $|V|$ и другие параметры графа --- это точнее
и охватывает большее число случаев --- например, когда граф
заведомо разреженный
(через длину входа всегда сможем выразить).
\end{remark}
%-----------------------------------------------------------
\section{Поиск в глубину и ширину в дереве}
Связность, путь, цикл, ацикличность, дерево, дерево с корнем.
Поиск в глубину и ширину: стек и очередь.

\gap

%-----------------------------------------------------------
\section{Поиск в глубину в графе}
Рекурсивно обрабатываем вершины 
(ориентированного или неориентированного) графа
так, чтобы каждую вершину и каждое ребро обработать ровно один раз.
Просматривая каждую вершину или ребро, вызываем некую
внешнюю процедуру, которая выполняет действия, которые требуется произвести
над каждым ребром или вершиной (в том, чтобы применить эту процедуру
к каждой вершине и/или каждому ребру, и есть назначение поиска в глубину).

Именно, отмечаем вершину $v$, которую начали обрабатывать
(проставляем момент времени $b[v]$ начала ее обработки).
Затем \emph{последовательно} рассматриваем всех ее соседей $v_i$:
если $v_i$ еще не начали обрабатывать, рекурсивно
обрабатываем $v_i$ (заметим, что в процессе рекурсивной обработки
вершины $v_i$ мы можем обработать $v_{i+1}$!).
Закончив эти рекурсивные вызовы, проставим момент $e[v]$ конца обработки
вершины $v$.
\begin{remark}
Заметим, что начало и конец обработки для всех вершин
образуют скобочную структуру (не может быть $b[v]<b[v']<e[v]<e[v']$).
\end{remark}

Если после вызова этой рекурсивной процедуры из <<главной программы>>
в графе остались необработанные вершины, берем любую из них и обрабатываем 
той же процедурой --- и так,
пока необработанные вершины не кончатся.

Побочным эффектом поиска в глубину является возможность построения
\emph{леса поиска в глубину} --- совокупности ребер, по которым
мы шли, совершая рекурсивные вызовы (\emph{лес} --- это граф,
являющийся объединением нескольких не связанных между собой деревьев).

\begin{lemma}\label{lem:dfs-corr}
Каждая вершина будет обработана ровно один раз.
Каждое ориентированное ребро будет проверено (в цикле поиска соседей)
ровно один раз.
\end{lemma}
\begin{proof}
Мы никогда не начинаем обработку вершины, которую уже обрабатывали.
\end{proof}

\begin{lemma}\label{lem:dfs-time}
Поиск в глубину занимает $O(|E|+|V|)$ операций с вершинами и ребрами,
т.е. время $O((|E|+|V|)\log |V|)$ (не считая времени, затрачиваемого
внешней процедурой).
\end{lemma}
\begin{proof}
Следует из леммы~\ref{lem:dfs-corr}.
Обращений к каждой вершине и данным, с ней связанным, --- 
не более, чем количество ее соседей 
(значит, всего таких обращений --- $O(|E|)$).
\end{proof}
\begin{remark}
Тут важно представление графа: матрица смежности не подойдет!
(Сразу получится время $O(|V|^2)$.) 
\end{remark}

\subsection{Топологическая сортировка}

\paragraph{Задача} о топологической сортировке вершин ориентированного графа:
расположить вершины ориентированного графа в таком порядке, чтобы все ребра шли от меньшей
(в этом порядке) вершины к большей.

\paragraph{Решение:} применить поиск в глубину и отсортировать вершины по
убыванию времени окончания обработки.

\begin{remark}
На сортировку не требуется дополнительного времени:
можно во время поиска складывать полностью обработанные вершины в стек.
\end{remark}

\begin{lemma}
В графе без (ориентированных) циклов
сортировка по убыванию времени окончания обработки
является топологической сортировкой. 
\end{lemma}
\begin{proof}
Пусть в графе имеется ребро $(v,w)$, хотя $e[v]<e[w]$.
Есть два варианта <<скобочной структуры>>: 
\smallskip
\begin{enumerate}
\item[\{\}():] $b[v]<e[v]<b[w]<e[w]$, но это противоречит тому, что
   поиск в глубину делает рекурсивный вызов для всех соседей $v$,
   обработка которых еще не началась (в частности, для $w$);
\smallskip
\item[\{()\}:] $b[w]<b[v]<e[v]<e[w]$, но это означает, что есть ориентированный
   путь из $w$ в $v$, т.е. имеется ориентированный цикл.
\end{enumerate}
\end{proof}

\begin{remark}
Если же в графе имеются ориентированные циклы,
то топологическую сортировку произвести невозможно.
\end{remark}

\subsection{Компоненты сильной связности}

\paragraph{Задача:} разбить ориентированный граф на компоненты сильной связности,
т.е. на подмножества вершин, в каждом из которых
имеется (ориентированный) путь из любой вершины в любую (в обоих направлениях), 
а для любых двух вершин $u$ и $v$ из разных компонент 
либо нет пути из $u$ в $v$, либо нет пути из $v$ в $u$.

\paragraph{Решение:}
\begin{itemize}
\item произвести поиск в глубину, найдя время окончания обработки
$e[v]$ для каждой вершины;
\item произвести поиск в глубину в графе $G^t$, отличающемся от графа
$G$ тем, что ребра в нем идут в 
противоположном направлении; причем следующую вершину $v$
для вызова процедуры рекурсивного поиска из <<главной программы>>
выбирать в порядке убывания $e[v]$;
\item полученные деревья поиска в графе $G^t$ и будут сильно связными компонентами.
\end{itemize}

\begin{lemma}\label{lem:subtree}
При поиске в глубину, если есть путь из $v$ в $w$,
и вершина $v$ начала обрабатываться до вершины $w$,
то вершина $w$ попадет в то же самое дерево
поиска, что и $v$.
\end{lemma}
\begin{proof}[Доказательство (индукция по длине пути).]
Пусть $y$ --- первая вершина на пути из $v$ в $w$,
не попавшая в то же дерево поиска, что и $v$,
а $x$ --- последняя попавшая туда вершина 
(т.е. $x$ идет непосредственно перед $y$ в этом пути).

Если бы обработка вершины $y$ еще не была начата,
когда началась обработка вершины $x$,
то $y$ безусловно попала бы в то же дерево поиска, что и $x$ (а значит,
то же, что и $v$). Если бы обработка $y$ была начата, но не закончена
до начала обработки $x$,
ситуация была бы такой же, поскольку одновременно могут обрабатываться
только вершины, попадающие в одно дерево поиска. Более того, то же самое
было бы, если бы обработка $y$ не была закончена до начала обработки $v$. 

Следовательно, вершина $y$ уже была обработана к тому моменту, когда
была начата обработка вершины $v$. По предположению индукции, $y$ и $w$
попали в одно и то же дерево поиска, но это противоречит тому, что 
обработка $w$ еще не была начата, когда начала обрабатываться вершина $v$!
\end{proof}

\begin{theorem}\label{components}
Описанная выше процедура корректна.
\end{theorem}
\begin{proof}[Доказательство (в котором мы пользуемся леммой~\ref{lem:subtree})]
1) Пусть две вершины $v$ и $w$ связаны в обе стороны, но не попали в одно
дерево поиска графа $G^t$. Пусть дерево, содержащее вершину $v$, возникло
раньше. Но тогда %по лемме \ref{lem:subtree}
$w$ обязана была попасть в это дерево.

2) Пусть пути из $v$ в $w$ нет, но они попали в одно дерево.
Достаточно показать, что имеется путь из
корня $r$ этого дерева в обе вершины $v$ и $w$ (пока мы только знаем,
что есть обратные пути).

Пусть $p$ --- последняя вершина на пути из $v$ в $r$ 
в дереве поиска для графа $G^t$, которая не лежит в той же компоненте,
что и $r$; а $q$ --- следующая за $p$ на этом пути.
Нам достаточно показать наличие пути из $q$ в $p$.

Поскольку $e[r]>e[p],\;e[q]$ в дереве поиска для исходного графа $G$,
имеется два варианта.
\smallskip
\begin{enumerate}
\item[(а)] 
Вершина $q$ лежит в поддереве с корнем $r$. 
Если $p$ лежит на пути из $r$ в $q$ в этом поддереве,
то получаем требуемое утверждение.
Если $p$ была обработана раньше $q$, то также
существует путь из $q$ в $p$ в этом дереве. 
Остается случай, когда $p$ начала обрабатываться
позже $q$ (и позже $r$!). Но, поскольку ее обработка закончилась все же раньше $r$,
то она попала в поддерево с корнем $r$.
\smallskip
\item[(б)] Вершина $q$ была полностью обработана до начала обработки $r$.
Если бы $p$ была обработана раньше $q$, но по ребру $(p,q)$ мы не пошли,
то существовал бы путь из $q$ в $p$.
Значит, $p$ --- родитель $q$.
Однако почему вершина $r$ не попала в поддерево поиска с корнем $q$?
Значит, на пути из $q$ в $r$ есть вершина $x$, которая уже начала
обрабатываться до того, как $q$ была обработана, --- т.е. есть
путь из $q$ в $p$ через $x$.
\end{enumerate}
\end{proof}

\subsection{Упражнения}
\begin{exercise}[Полусвязность]
Ориентированный граф называется полусвязным, 
если для любых двух его вершин $v$ и $w$
в нем имеется (ориентированный) путь либо из $v$ в $w$,
либо из $w$ в $v$.
Выяснить, является ли данный граф полусвязным.\qed
\end{exercise}

\noindent
\begin{proof}[Решение]
Найти сильно связные компоненты, стянуть каждую из них в точку,
применить алгоритм топологической сортировки; если в полученном
порядке для каждой вершины есть ребро в следующую, то
граф --- полусвязный, иначе --- нет.
\end{proof}

\begin{exercise}[Мосты и точки раздела]
Дан неориентированный связный граф.
Точкой раздела называется вершина, при удалении которой граф теряет связность.
Мостом называется ребро, при удалении которого граф теряет связность.
Найти в данном графе все мосты и точки раздела.\qed
\end{exercise}

%-----------------------------------------------------------
\section{Построение минимального остовного дерева}
\emph{Остовное дерево} (неориентированного графа) --- это дерево,
содержащее все вершины графа и некоторые из его ребер.

Для данного графа с весами
построим остовное дерево с минимальным суммарным весом ребер. 
%(Считаем, что все ребра разного
%веса: этого можно добиться, если к равным ребрам добавить
%достаточно малые $\varepsilon_i$.)
%Крускал/Борувка: m log n
%Борувка: можно улучшить вероятностно --- а Краскала, если сортировать вероятностно?
%Прим: можно n log n --- Фибонначиевы кучи
Будем <<растить>> дерево постепенно.
В процессе построения будет получаться некоторый лес, являющийся
подграфом будущего остовного дерева.
На каждом шаге будем добавлять к этому лесу ребро минимального возможного веса,
соединяющее некоторую компоненту связности $C$ с вершиной \emph{другой} компоненты
(минимум берется по всем ребрам, исходящим из компоненты $C$;
выбор компоненты $C$ --- произволен).

\begin{lemma}
Такой алгоритм корректен независимо от способа выбора
очередной компоненты (и ребра среди ребер одинакового веса).
\end{lemma}
\begin{proof}[Доказательство (индукция по построению дерева).]
Пусть, имея лес $F$, мы добавили к нему ребро $(u,v)$,
минимальное по весу из ребер, соединяющих некоторую компоненту $U$ 
с другими компонентами леса $F$.
Считая (по предположению индукции),
что существует минимальное остовное дерево $T$ исходного графа, содержащее лес $F$,
покажем, что существует и минимальное остовное дерево,
содержащее $F\cup\{(u,v)\}$.

Итак, пусть $T$ не содержит $(u,v)$.
Тем не менее, в $T$ есть путь $\gamma$ из $u$ в $v$ (не содержащий
ребра $(u,v)$). Рассмотрим первое ребро $e$ на пути $\gamma$,
выводящее за пределы компоненты $U$.
Наш алгоритм устроен так, что вес ребра $e$ --- не меньше веса ребра $(u,v)$.
Следовательно, $T\setminus \{e\}\cup \{(u,v)\}$ --- 
искомое минимальное остовное дерево.
\end{proof}

Имеется несколько возможных реализаций этого алгоритма. 

\medskip
\begin{description}
\item[Алгоритм Борувки.] % Bor{\r u}vka.] 
На очередном шаге выбираем для каждой вершины
(одновременно) ребро минимального веса, исходящее из нее.
Затем \emph{стягиваем каждую из получающихся из этих ребер компонент
связности в одну точку}.
%      Стягивать каждую из имеющихся компонент связности в одну точку
%      (одновременно для нескольких компонент)
%      и на очередном шаге выбирать для каждой вершины
%      (снова одновременно) ребро минимального веса, исходящее из нее.
\item[Алгоритм Крускала.] %Kruskal.]
      Рассматриваем все ребра в порядке, соответствующем весу;
      очередное ребро добавляем к лесу, если оно соединяет разные
      компоненты связности.
\item[Алгоритм Прима.] %Prim.]
      Конструируемый нами лес состоит из дерева и независимых вершин.
      Выбираем ребро минимального веса среди ребер, соединяющих вершины
      нашего дерева с остальными вершинами.
\end{description}
Легко видеть, что любой из этих методов можно реализовать за 
$O(|E|\log |V|)$ операций с вершинами \emph{и весами}.
Например, в первом из этих методов на каждом шаге количество вершин
уменьшается, как минимум, вдвое; каждый шаг можно реализовать за $O(|E|)$ операций
с вершинами и ребрами:
поиск минимального элемента занимает линейное время,
слияние списков, содержащих $|E|$ элементов, --- время $O(|E|)$;
при стягивании ребра, ведущие в вершины той же компоненты,
можно не удалять, а считать б\'ольшими по весу.

\begin{problem}
Доказать корректность алгоритма Борувки.
\end{problem}
%-----------------------------------------------------------
\section{Нахождение кратчайших путей}
Задача: в ориентированном графе
с заданными длинами ребер
найти кратчайшие пути из одной вершины $s_0$ во все остальные.
(На самом деле, <<найти пути>> здесь означает <<для каждой вершины $v$ найти
длину кратчайшего пути из $s_0$ в $v$ 
и предыдущую вершину $p[v]$ на каком-нибудь кратчайшем пути из
$s_0$ в $v$>>.)

\subsection{Алгоритм Дейкстры}
В алгоритме Дейкстры предполагается, что длины всех ребер $w(v_1,v_2)$ 
неотрицательны. Этот алгоритм похож на алгоритм Прима:
мы постепенно подсчитываем кратчайшие расстояния $d[s]$ 
(и находим кратчайшие пути)
для все большего числа вершин $s$ --- множество $S$ обработанных вершин
растет на каждом шаге.
Длины путей до вершин, не входящих в $S$, мы тоже подсчитываем,
но на промежуточных этапах это будут еще не кратчайшие пути.

На очередном шаге добавляем к множеству $S$ вершину $u\in V\setminus S$,
для которой $d[u]$ минимально (в дальнейшем будет показано, что это
автоматически означает, что $d[u]$ уже подсчитано правильно). Далее учитываем
этот факт: для каждой соседней с $u$ вершины $v\notin S$
корректируем $d[v]$ следующим образом: $d[v]:=\min\{d[v],\ d[u]+w(u,v)\}$.
Если $d[v]$ уменьшилось, 
отмечаем $u$ как предыдущую вершину на 
кратчайшем пути из $s_0$ в $v$.

%Очевидно, каждое ребро просматривается в этом алгоритме
%лишь однажды --- при включении одного из его концов в $S$.
%Кроме этого 
Для добавления очередной вершины надо ее найти
(для этого достаточно $O(|V|)$ операций) 
и просмотреть всех ее соседей
(в сумме для всех вершин --- $O(|E|)$ операций).
Итого получается $O(|E|)+|V|\cdot O(|V|) = O(|V|^2)$
операций с вершинами, ребрами \emph{и длинами путей}.
%Время работы алгоритма --- $O(|V|^2 \log|V| \log M$,
%где $M$ --- длина самого длинного\footnote{На самом деле не самого\REF{?}} 
%несамопересекающегося пути в нашем графе.

\begin{remark}
Можно найти способ представить данные в алгоритме Дейкстры 
так, чтобы ограничиться $O((|V|+|E|) \log |V|)$
и даже $O(|V|\log |V|+|E|)$ операциями.
\end{remark}

\begin{theorem}\label{th:dijkstra-corr}
Алгоритм Дейкстры правильно находит кратчайшие пути.
\end{theorem}
\begin{proof}[Доказательство (индукция по построению множества $S$).]
Пусть на очередном шаге мы добавили к множеству $S$ вершину $u$,
но на самом деле имеется путь длины $\delta<d[u]$. Рассмотрим первое ребро
$(s,t)$ на этом пути из $s_0$ в $u$, выводящее за пределы множества $S$;
пусть $\gamma(t,u)$ --- длина остатка этого пути от $t$ до $u$.

По предположению индукции, $d[s]$ --- длина кратчайшего пути до $s$.
Таким образом, 
\begin{eqnarray*}
\delta
&=&
d[s]+w(s,t)+\gamma(t,u)\ge\\
&&\mbox{\tiny(поскольку алгоритм Дейкстры обязательно учел ребро $(s,t)$ 
при добавлении вершины $s$)}\\
&\ge& 
d[t]+\gamma(t,u)\ge\\
&&\mbox{\tiny(по выбору $u$)}\\
&\ge&
d[u]+\gamma(t,u)\ge\\
&\ge&
d[u],
\end{eqnarray*}
что противоречит тому, что $\delta<d[u]$.
%Имеем $d[u]\le d[t]+\gamma(t,u)<d[u]$ (первое неравенство ---
%по выбору $u$ и неотрицательности $\gamma(t,u)$) --- противоречие!
% --- иначе говоря, по неравенству треугольника 
\end{proof}

\subsection{Алгоритм Беллмана-Форда}
Рассмотрим теперь случай, когда некоторые ребра имеют отрицательную длину.
%Неравенство треугольника в таком графе не выполняется,
%и поэтому 
Как видно из доказательства теоремы~\ref{th:dijkstra-corr},
алгоритм Дейкстры может на таком графе работать неправильно.
\begin{exercise}
Построить конкретный пример (без циклов отрицательной длины),
на котором алгоритм Дейкстры работает неправильно.\qed
\end{exercise}

Будем предполагать, что в графе нет циклов отрицательной длины,
достижимых из $s_0$ (если они есть, некоторые из кратчайших
расстояний будут равны $-\infty$ --- в этом случае алгоритм будет выдавать ошибку).

Алгоритм Беллмана-Форда пользуется теми же данными $d[v]$ и $p[v]$, 
что и алгоритм Дейкстры.
Он прост: $|V|-1$ раз повторить следующую операцию:
для каждого ребра $(u,v)$, если $d[u]+w(u,v) < d[v]$,
то $d[v]:=d[u]+w(u,v)$ и $p[v]:=u$.
Если после всех этих итераций для какого-то ребра по-прежнему
$d[u]+w(u,v) < d[v]$, значит, есть цикл отрицательной длины,
и можно выдать ошибку.

Очевидно, этот алгоритм затрачивает $O(|V|\cdot|E|)$ операций.

\begin{theorem}\label{th:bf-corr}
Алгоритм Беллмана-Форда корректно находит кратчайшие пути либо
обнаруживает цикл отрицательной длины.
\end{theorem}
\begin{proof}
Индукция по количеству ребер в пути (а их $\le |V|-1$);
предположение индукции:
после $i$-й итерации правильно найдены расстояния до вершин,
у которых в кратчайшем пути $\le i$ ребер.

Что же касается цикла отрицательной длины --- если он есть,
но строгое неравенство $d[u]+w(u,v) < d[v]$ не выполняется ни для одного
из его ребер $(u,v)$, сложим все обратные неравенства и получим,
что длина этого цикла неотрицательна (противоречие).
\end{proof}

\subsection{Рекурсивный алгоритм для определения длины кратчайшего пути}
Нашей следующей задачей будет определение кратчайших путей для
всех пар вершин графа. Перед этим изучим другой алгоритм, основанный
на следующем простом соображении.

Очевидно, что кратчайший путь из вершины $x$ в вершину $y$ из $\le t$ ребер
можно разбить на два пути из $\le \lceil t/2\rceil$ ребер каждый:
кратчайший путь из $x$ в некоторую вершину $z$ и кратчайший путь
из $z$ в $y$.

Эта идея приводит к следующему рекурсивному алгоритму для нахождения
\emph{длины} кратчайшего пути из вершины $s$ в вершину $t$,
затрачивающему лишь $O(\log|V|)$ ячеек памяти размера 
$O(\log|V|+\log\max\textrm{длин ребер})$ в предположении, 
что граф задан неявно (т.е. имеется лишь функция,
определяющая по $u$ и $v$ длину $w(u,v)$ ребра $(u,v)$).

\medskip\noindent
function shortest$(x,y,t)$ : $\mathbb{R}\cup\{+\infty\}$;\\
begin
\begin{itemize}
\item[] if $x=y$ then return $0$;
\item[] if $t=1$ then return $w(x,y)$;\hfill(*может быть $+\infty$*)\\[-8pt]
\item[] best $:=+\infty$;
\item[] for $z:=1$ to $|V|$ do
\item[] begin
\begin{itemize}
\item[]   new:=shortest$(x,z,\lceil t/2\rceil)$+
               shortest$(z,y,\lceil t/2\rceil)$;
\item[]   if new<best then best:=new;
\end{itemize}
\item[] end;
\item[] return best; 
\end{itemize}
end;\\

Вызов из главной программы: shortest$(s,t,|V|-1)$.

Временн\'ая сложность этого алгоритма велика.
\begin{exercise}
Определить ее.\qed
\end{exercise}

\subsection{Пути между всеми парами вершин}
Подобно тому, как мы уже делали,
воспользуемся динамическим программированием,
чтобы избавиться от рекурсии.
Заодно мы найдем и длины всех кратчайших путей
между всеми парами вершин, и сами кратчайшие пути,
причем быстрее, чем если бы мы $|V|$ раз повторили
алгоритм Беллмана-Форда.

\paragraph{Алгоритм Флойда-Уоршолла.}
Будем постепенно заполнять трехмерный массив $d$, где
$d_{ij}^{(k)}$ --- длина кратчайшего пути из вершины $i$ в вершину $j$
с промежуточными вершинами \emph{только} из множества $\{1,\ldots,k\}$.

Значения при $k=0$ --- это длины ребер исходного графа,
т.е. $d_{ij}^{(0)}=w(i,j)$.
Далее массив заполняется для возрастающих $k$,
а при постоянном $k$ --- для всех $i$ и $j$,
%возрастающих $i$,
%при постоянном $i$ --- для возрастающих $j$
по формуле
\[
  d_{ij}^{(k)} = \min \{ d_{ij}^{(k-1)},\ d_{ik}^{(k-1)}+d_{kj}^{(k-1)} \}.
\]
Корректность алгоритма и время его работы $O(|V|^3)$ очевидны.
\begin{exercise}
Заодно определить и матрицу $p$, где $p_{ij}$ --- предпоследняя вершина
на кратчайшем пути из $i$ в $j$.\qed
\end{exercise}
%
% The lecture
%
%-----------------------------------------------------------
\section{Задача о максимальном потоке}
\subsection{Лемма о максимальном потоке и минимальном сечении}
Дан ориентированный граф $G=(V,E)$ 
с пропускными способностями ребер,
заданными отображением $c:E\rightarrow\mathbb{R}$.
(Для простоты полагаем $c\equiv 0$ на $V\times V\setminus E$.)
Указаны источник $s\in V$ и сток $t\in V$.

\begin{definition}
Отображение $f:V\times V\rightarrow\mathbb{R}$ 
называется \emph{потоком} в $G$, если 
\[\forall u,v\in V\ \ f(u,v)\le c((u,v)),\]
\[\forall u,v\in V\ \ f(u,v)=-f(v,u),\]
\[\forall v\in V\sum\limits_{u:(u,v)\in E} f(u,v) = \sum\limits_{w:(v,w)\in E} f(u,v).\]
Величина $\sum\limits_{w:(s,w)\in E} f(s,w)$ 
(она же $\sum\limits_{u:(u,t)\in E} f(u,t)$) называется \emph{значением} потока.
\end{definition}

Требуется найти поток с наибольшим значением --- \emph{максимальный поток}.

\begin{definition}
Сечением в ориентированном графе называется разбиение $V$ на 
два непустых непересекающихся множества
$V_1$ и $V_2$. 
Также сечением называется множество ребер $(v_1,v_2)$,
таких, что $v_1\in V_1$ и $v_2\in V_2$ (но не наоборот!).
Пропускной способностью сечения называется 
суммарная пропускная способность этих ребер.
Потоком через сечение называется суммарный поток 
\[\sum_{v_1\in V_1,\;v_2\in V_2} f(v_1,v_2)\]
через эти и обратные (соответственно, с обратным знаком) ребра.

Нас будут интересовать \emph{$s-t$-сечения},
т.е. такие, что $s\in V_1$, $t\in V_2$.
В дальнейшем будем их называть просто \emph{сечениями}.
Несложно увидеть, что поток через любое $s-t$-сечение
совпадает со значением потока в нашем графе.
\end{definition}

\begin{definition}
Остаточной сетью $G_f$ для данного потока $f$ в графе $G$
называется множество ребер $(u,v)$, для которых 
$c_f((u,v)):=c((u,v))-f(u,v)>0$.
Дополняющим путем называется путь $\gamma$ из $s$ в $t$ в остаточной сети.
Очевидно, при наличии дополняющего пути поток можно увеличить
на $\min\limits_{e\in\gamma} c_f(e)$.
\end{definition}

\begin{remark}
Заметим, что в остаточной сети могут появиться ребра,
которых не было в исходном графе --- именно, ребра,
обратные к тем, по которым течет положительный поток.
\end{remark}

\begin{lemma}[о максимальном потоке и минимальном сечении]
Следующие три условия эквивалентны.
\begin{enumerate}
\item Поток $f$ --- максимальный.
\item В остаточной сети $G_f$ не имеется дополняющих путей.
\item Имеется сечение, пропускная способность которого равна 
потоку через это сечение.
\end{enumerate}
\end{lemma}
\begin{proof}
<<1>>$\Rightarrow$<<2>> и <<3>>$\Rightarrow$<<1>> очевидны. 
Докажем <<2>>$\Rightarrow$<<3>>.
Рассмотрим множество $S$ вершин, достижимых из $s$ в графе $G_f$.
По <<2>>, $V\setminus S\neq\emptyset$.
Сечение $S$, $V\setminus S$ --- искомое.
%Пусть пропускная способность каждого сечения строго больше потока через
%это сечение. Построим дополняющий путь итеративно, ребро за ребром.
%На самом деле, кроме собственно пути, в множество $S$ (изначально содержащее
%лишь $s$), которое мы строим, будут входить и другие вершины, достижимые из 
%$s$ в $G_f$. % путями, пропускная способность которых не полностью израсходована. 
%Рассмотрим сечение $S$, $V\setminus S$.
%Его пропускная способность строго больше потока через него, 
%поэтому к $S$ можно добавить еще одну вершину.
%Рано или поздно, в $S$ попадет и сток.
\end{proof}

\subsection{Алгоритм Форда-Фалкерсона}
Алгоритм чрезвычайно прост: будем находить дополняющий путь и увеличивать
поток на пропускную способность этого пути (т.е. минимум из пропускных
способностей ребер остаточной сети, который составляют этот путь).
Корректность алгоритма очевидна (если он остановится!).
Однако, в зависимости от пропускных способностей и конкретной реализации
этого алгоритма, время его работы может быть различным (в том числе, он может и
зациклиться). Рассмотрим несколько случаев:

\begin{description}
\item[Целочисленные пропускные способности.] В этом случае алгоритм можно
легко реализовать за $O(M|E|)$ операций, где $M$ --- значение максимального
потока. В самом деле, добавляя каждый дополняющий путь, мы увеличиваем
значение потока по крайней мере на единицу. Дополняющий путь же можно
найти поиском в глубину (или ширину) 
и убрать из остаточной сети за линейное количество операций.

\item[Алгоритм Эдмондса-Карпа.] Если $M$ велико (или веса --- не
целочисленные), оценка для предыдущего алгоритма будет не слишком хороша.
Покажем, что если искать дополняющие пути поиском в ширину,
будет найдено лишь $O(|V|\cdot|E|)$ дополняющих путей,
т.е. количество операций будет $O(|V|\cdot|E|^2)$.

\medskip
{
\leftskip 12mm
\small

\paragraph{\small{}Отступление: поиск в ширину.}
Поиск в ширину преследует ту же цель, что и поиск в глубину:
обработать все вершины графа.
В отличие от поиска в глубину, основанного на рекурсии, а значит,
использующего стек, поиск в ширину можно реализовать при помощи очереди.
Очередная вершина вынимается из начала очереди (при инициализации в очередь помещается
только одна вершина --- корень будущего дерева поиска), обрабатывается,
и ее сыновья --- те, которых еще нет в очереди, --- кладутся в ее конец.
Если очередь опустеет, туда кладется следующая необработанная вершина, 
и\;т.\,д.
Очевидно, этот алгоритм корректен и использует линейное число операций.

}
\medskip

<<Искать путь из $s$ в $t$ поиском в ширину>> означает <<запустить
поиск в ширину, начав его с вершины $s$, и прервать, как только
в очередь попадет вершина $t$>>.
Заметим, что поиск в ширину находит путь, состоящий из наименьшего
количества ребер (кратчайший): в нем сначала обрабатываются вершины,
находящиеся на расстоянии 1 от $s$, затем --- на расстоянии $2$, и\;т.\,д.
\medskip

Назовем ребро $e$ в дополняющем пути $\gamma$ \emph{критическим}, если
на нем достигается $\min\limits_{e\in\gamma} c_f(e)$. При удалении
очередного дополняющего пути хотя бы одно из его ребер оказывается
критическим. Значит, для доказательства искомой верхней оценки достаточно
доказать следующую лемму (заметим, что ребер, рассматриваемых нашим алгоритмом,
не может быть более $2|E|$).

\medskip
\begin{lemma}\label{lem:ff:critical}
Ребро может стать критическим лишь $O(|V|)$ раз.
\smallskip\small\begin{remark}
\leftskip 12mm
Заметим, что ребра пропадают, оказываясь критическими на 
выбранном дополняющем пути, а появляются, когда обратные
ребра оказываются (необязательно критическими) на выбранном дополняющем пути.
\end{remark}
\end{lemma}

\begin{proof}
Будем обозначать через $d(x,y)$ расстояние между вершинами в очередной
остаточной сети.

{
\small
\begin{lemma}[к лемме~\ref{lem:ff:critical}]\label{lem:ff:up}
\leftskip 12mm
Расстояние $d(s,y)$ не убывает.
\end{lemma}
\begin{proof}
\leftskip 12mm
Пусть оно уменьшилось, а поток при этом увеличился с $f$ до $f'$.
НУО можем считать, что $y$ --- ближайшая к $s$ в $G_{f'}$
вершина с таким свойством.
%Для тех вершин $x$, для которых расстояние стало меньше, чем до $y$,
%оно не уменьшилось. -- ОЧЕВИДНО
Рассмотрим вершину $x$, предшествующую $y$ на кратчайшем пути из
$s$ в $y$ в $G_{f'}$. До этой вершины, по предположению, 
расстояние не уменьшилось.

\smallskip
Следовательно, ребро $(x,y)$ возникло при переходе от $f$ к $f'$,
т.е. соответствующий дополняющий путь содержал $(y,x)$. Он был
кратчайшим; значит, было $d(s,x)-1 = d(s,y)$. Но $d(s,x)$ не уменьшилось,
и $d(s,y)$ стало больше, чем $d(s,x)$; следовательно, $d(s,y)$
увеличилось! 
\end{proof}
}

Ребро $(u,v)$ пропадает тогда и только тогда, когда оно становится
критическим в каком-то дополняющем пути.
Поскольку это ребро лежит на кратчайшем пути, до этого было $d(s,v)=d(s,u)+1$.
Ребро $(u,v)$ появляется вновь, если ребро $(v,u)$ входит в какой-то дополняющий
путь. 
Поскольку теперь уже $(v,u)$ лежит на кратчайшем пути, перед этим моментом
было $d(s,u)=d(s,v)+1$.
Но эти расстояния не убывают (по лемме~\ref{lem:ff:up})!
Следовательно, в промежутке между двумя моментами, когда ребро $(u,v)$
побывает критическим, расстояние $d(s,v)$ увеличится на 2.
Но оно не может стать больше $|V|-1$!
\end{proof}

\end{description}

\subsection{Метод проталкивания предпотока}

\gap

\subsection{Применение алгоритма Форда-Фалкерсона для нахождения максимального
паросочетания в двудольном графе}

\begin{definition}
Неориентированный граф $(V,E)$ называется \emph{двудольным},
если множество его вершин разбито на два непересекающихся множества 
$V_1$ и $V_2$, таких, что $\forall i\,\forall u,v\in V_i\;\, \{u,v\}\notin E$.
\end{definition}

\begin{definition}
Паросочетанием в неориентированном графе $(V,E)$ 
называется множество $E'\subseteq E$, такое, что 
$\forall e_1, e_2\in E'\;\, e_1\cap e_2=\emptyset$.
\end{definition}

Найдем в двудольном графе паросочетание, состоящее из 
наибольшего количества ребер. Для этого модифицируем граф:
сделаем его ориентированным (направление всех ребер --- из $V_1$ в $V_2$),
добавим источник $s$ и ребра $(s,v_1)$ для всех $v_1\in V_1$,
а также сток $t$ и ребра $(v_2,t)$ для всех $v_1\in V_2$.
Пропускные способности всех ребер положим равными единице.
Применим алгоритм Форда-Фалкерсона. Как нетрудно заметить,
ребра, по которым будет течь найденный им максимальный поток,
и дадут максимальное паросочетание.
Поскольку в нем не может быть более $|V|/2$ ребер,
алгоритм совершит лишь $O(|V|\cdot|E|)$ операций.
\end{document}

