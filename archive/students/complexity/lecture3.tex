\documentclass[12pt,a4paper]{book}

\usepackage[koi8-r]{inputenc}

\usepackage[russian,english]{babel}

\usepackage{amsthm,amssymb, amsmath}
\pagestyle{plain}

\input defs
\newcommand{\nl}{\newline}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\Im}{{\rm{Im}\;}}

\DeclareMathOperator{\const}{const} 

\begin{document}
\selectlanguage{russian}

\lecture{3}{Криптосистемы с открытым ключом,
кодирующие один бит}{И. Сергей}


\section{Постановка задачи }
Алиса (\textbf{А}) и Боб (\textbf{B}) обмениваются сообщениями через 
ненадежный канал, прослушиваемый Чарли (\textbf{C}). Боб отправляет 
сообщение Алисе. Хотелось бы, чтобы она его получила, а Чарли не 
понял, что там имелось в виду. Для этих целей Алиса генерирует ключ, 
отправляемый Бобу. Само собой, этот ключ известен Чарли. После этого 
Алиса использует другой ключ, чтобы раскодировать полученное от Боба 
сообщение. Чарли же таким ключом не обладает. %%
\section {Основные определения}
Поскольку всё на свете можно зашифровать по одному биту,
для начала ограничимся случаем $m \in \{0,1\}$.
\begin{definition}
Криптосистема с открытым кючом --- это полиномиальный по времени 
детерминированный алгоритм $G$, которому на вход подают параметр
надежности (в унарной системе) и строчку случайных битов. А он по 
этой паре однозначно порождает две булевых схемы: для кодирования и 
для раскодирования. 
\[G: \; (1^n, r_g) \mapsto (e,d),\]
где $e$ --- открытый ключ, а $d$ --- секретный ключ. При этом, схемы $e$ 
и $d$ работают следующим образом. На вход подается сообщение $m\in\{0,1\}$ 
после чего 
$e$ порождает по нему код какой-то (очевидно, полиномиальной от 
длины исходного сообщения) длины $c$: 
\[e(m, r_e) \in \{0,1\}^*. \]
\begin{remark}
Кодирующая функция обязательно должна брать случайные биты. В 
противном случае ноль и единица кодируются 
всегда одним и тем же образом. О надежности протокола в этом случае 
говорить не приходится. 
\end{remark}
В свою очередь, $d$ принимает на вход код и, возможно, некоторые 
случайные биты $r_d$. Для корректной работы системы естественным 
является условие:
\[d(e(m,r_e),r_d) = m,\]
но мы его не всегда будем требовать.
\begin{remark}
Заметим, что определение не говорит ничего 
о надежности такой криптосистемы.
\end{remark}

Система $\delta$-\emph{корректна} (\emph{$\delta$-PKCS}), если 
$$\forall m  \;\; \Pr\{d(e(m,r_e),r_d) = m\} \ge \delta$$
Вероятность берется по всем случайным битам, принимаемыми нашими 
схемами на вход (в том числе по $r_g$).
\end{definition}
\begin{remark}
1-PKCS (или просто \emph{PKCS}) --- система, которая кодирует и раскодирует без ошибкок.
\end{remark}
\begin{remark}
Если мы захотим кодировать сразу много битов,
нам придётся модифицировать определение,
поскольку схема $e$, как и любая другая схема,
имеет фиксированное количество входов.
Достаточно добавить алгоритмы $E$ и $D$, которые могут пользоваться
$e$ и $d$ соответственно; кодировать и раскодировать в этом
случае будем этими алгоритмами.
\end{remark}
Теперь мы хотим, чтобы 
Чарли не мог отличить код нуля от кода единицы.

\begin{definition} 
Криптосистема (для кодирования одного бита) называется \emph{надежной}, если
$$ \forall C \; \forall p \;\; \Pr\{C(e(m,r_e),1^n,e)=m\} \le \frac12 + \frac1{p(n)} \; ,$$ где
$C$ --- вероятностный полиномиальный по времени алгоритм, $p$ --- 
некоторый многочлен. Параметр $1^n$ дается для того, чтобы разрешить
взломщику работать время, полиномиальное от параметра надёжности,
а вероятность берется по всему, в том числе и по $m$ (равному
$0$ или $1$ равновероятно). 
\end{definition}
Получается, что $C$ решает задачу следующего рода. Мы даем ему 
какой-то код --- либо нуля, либо единицы. В системе без ошибок эти 
множества не пересекаются, $C$ должен их разделить (он должен
хотя бы иногда давать правильный ответ на этих множествах,
а как он ведёт себя за их пределами --- безразлично). Каждое из этих 
множеств по отдельности принадлежит классу $\NP$. В самом деле, в 
данном случае подсказкой являются случайные биты кодирующей схемы 
$e$. Имея их, мы сможем проверить правильность кода. \par Важно,
что наши некоторые строки не являются кодами ни $0$, ни $1$.
Представим себе систему, множество кодов которой представляет  собой 
все возможные двоичные строки.
Это будет означать, что мы ограничили себя множествами из $\NP\cap\coNP$.
Более того, если мы захотим, чтобы задача, которую мы решаем,
была $\NP$-трудной, нам придётся примириться с $\NP=\coNP$.
% Если теперь предположить, что задача 
%раскодирования нуля $\NP$-полная, то, так как альтернативная задача 
%тоже из $\NP$, мы получим $\NP = \coNP$. %%
\begin{remark}
Таким образом, задача раскодирования криптосистемы --- это 
частный случай разделения двух непересекающихся $\NP$-множеств 
(\emph{disjoint $\NP$ pairs}). Необходимость разделять такие
множества возникает не только в криптографии, но и в теории
сложности доказательств, где для автоматизации доказательства
требуется отделить множество (невыполнимых) формул, имеющих короткие доказательства,
от множества (выполнимых) формул, не имеющих доказательств.
\end{remark}

\section {PKCS на основе tdpf}
\begin{remark}
Почему в качестве криптосистемы с открытой ключом нельзя было 
воспользоваться tdpf?  Все дело в том, что определение 
\emph{trapdoor function} ничего не говорит о том, насколько сложно 
найти конкретный бит кодируемого сообщения. В случае сообщения из 
одного бита (а остальные биты в строке можем взять произвольным 
образом) \emph{trapdoor function} кодирует \emph{всю} 
строку, и ее найти по коду трудно. Но при этом, то, что нам надо 
(скажем, первый бит), может находиться сравнительно легко.
\end{remark}
Попытаемся построить надежную криптосистему на основе \emph{trapdoor 
function} $G$ с кодирующей схемой $e$. Генерируемая нашей
криптосистемой $G$ схема $e'$ будет работать 
следующим образом: $$ e'(m,r) = (e(r),B(r) \oplus m) ,$$ где $r$ --- 
наши случайные биты, а $B$ --- трудный бит для $e$. Дешифровщик $d'$ действует 
очевидным образом, обращая $e(r)$, получая затем $B(r)$ и делая 
XOR со второй компонентой кода.
\begin{theorem}
В принятых выше обозначениях, если  $G$ --- tdpf, а $B$ --- ее трудный 
бит, то $G'$ --- надежная криптосистема.
\end{theorem}

\begin{proof}
Пусть у нас есть взломщик, который ломает полученную криптосистему. 
Взломаем с его помощью изначальное tdpf, или, по 
крайней мере, его трудный бит.

Мы получили $e(r)$ и пытаемся угадать 
$B(r)$. Для этого берем случайную строку $b$, и пару $(e(r),b)$ даем 
нашему взломщику (заметим, что это код какого-то сообщения). Взломщик 
говорит нам некоторое $m$, и если он его действительно отгадал, то 
$m \oplus b$ --- искомый трудный бит. Взглянув на определения tdpf и 
PKCS, замечаем что все вероятности взлома --- такие, как нам надо, 
значит мы взломали трудный бит. А не должны были. 
\end{proof}
\begin{corollary}
$\exists$ tdpf  $\Rightarrow$ $\exists$ надежная криптосистема 
(PKCS).
\end{corollary}
\begin{exercise}
Доказать в обратную сторону.
\end{exercise}

\section {Криптосистема, полная в $\frac 23 - $PKCS}
Вспомним определение свед\'ения между owf из предыдущей лекции
и творчески его доработаем для криптосистем, поскольку надёжность
у нас теперь сильная, а значит, взлом --- слабый.
\begin{definition}
Алгоритм $A$ взламывает криптосистему $G$ с вероятностью $q(n)$,
если для бесконечной последовательности длин $n_i$
\[\Pr_{b\in\{0,1\},A,r_g,r_e}\{A(e(b,r_e),1^{n_i},e))=b\}\ge q(n_i).\]
\end{definition}
\begin{definition}
  $F \to G$ (взлом криптосистемы $F$ сводится к взлому криптосистемы $G$), если 
  $$\exists T^\cdot \; \forall p \; \exists p': $$ 
  $$ A\;\mbox{взламывает}\;G\;\mbox{с}\;\mbox{вероятностью}\;\frac12 + \frac{1}{p(n)} 
    \Rightarrow $$ 
  $$ T^A \;\mbox{взламывает}\;F\;\mbox{с}\;\mbox{вероятностью}\;\frac12+ \frac{1}{p'(n)}.$$
Здесь $T$ --- полиномиальная по времени оракульная машина Тьюринга, $A$ используется как \emph{вероятностный} оракул, $p(n)$ и $p'(n)$ --- многочлены (положительные при $n\ge1$).
\end{definition}

Итак, будем строить полную относительно этого сведения криптосистему 
$G$ в классе криптосистем, которые расшифровывают зашифрованное сообщение 
правильно с вероятностью $\frac 23$ ($\frac 23 - $PKCS). Наша 
криптосистема будет пользоваться всеми на свете криптосистемами. Для 
параметра надежности $n'$ можно воспользоваться первыми $n'$ 
криптосистемами. Кодирование будет производиться так, что, если хотя 
бы одна из рассмотренных криптосистем является надежной, то и наша 
криптосистема надежна. Построение происходит в три этапа. 
\begin{itemize}
\item[1.] \emph{\textbf{Сертификация.}} Для начала производится перебор алгоритмов и сертификация их в качестве криптосистем. 
В самом деле, нам подходит не любой алгоритм из перебираемых:
он должен порождать пары схем, обратных друг к другу (с хорошей вероятностью). Нам 
нужно отобрать первые $n'$ подходящих алгоритмов. Для этого мы 
производим проверку каждого из "<кандидатов">.
\begin{remark}
Мы перебираем алгоритмы, работающие некоторое, ограниченное 
конкретным полиномом (потом покажем, что этого достаточно),  время. 
\end{remark}
Сертификация проиходит следующим образом. Для каждого "<кандидата">
$G_i$ мы много раз производим шифрование и дешифрование случайных 
сообщений (однобитовых), выбирая различные случайные ключи. Если в 
подавляющем большинстве случаев получился правильный результат получился, 
добавляем нашего "<кандидата"> в список. Для
прохождения сертификации мы будет требовать чуть более $\frac 23$ 
правильных ответов.
\item[2.] \emph{\textbf{Amplification of correctness.}} Сделаем ошибку нашей криптосистем 
экспонициально малой. Для это много раз закодируем сообщение, а при 
раскодировании ответ возьмем по большинству. 
Следует проследить за тем, чтобы эта конструкция не уменьшила надежности.
\item[3.] \emph{\textbf{Объединение.}} Объединим все выбранные криптосистемы таким образом, что, если среди них была хоть 
одна надежная, то и полученная криптосистема будет надежной. Для 
этого кодируемый бит $b$ представим в виде $b = b_1 \oplus \ldots 
\oplus b_{n'}$, где $b_1 \ldots b_{n'-1}$ --- некоторые случайные 
биты, а $b_{n'} = b_1 \oplus \ldots \oplus b_{n'-1} \oplus b$. После 
этого каждый из битов кодируется своей криптосистемой. ``Понятно, что'' 
для для раскодирования взломщику нужно взломать все $n'$ 
криптосистем.
\end{itemize}


Покажем, что для взлома любой криптосистемы достаточно взломать 
только что нами построенную. Для взлома конкретной криптосистемы 
$G_*$, которой закодировали некоторый бит $b_*$, впишем его код на 
место соответствующего случайного бита, закодированного $G_*$ в 
нашей криптосистеме. (Для этого $n'$ нужно взять достаточно большим:
больше номера криптосистемы $G_*$.) 
Таким образом, по полученному значению бита $b$, зная все остальные 
случайные биты, мы получим и исходный бит $b_*$. 
\begin{remark}
Будем считать, что $G_1 = \textrm{id}$. Тем самым построенная криптосистема будет
правильно кодировать сообщения даже если не сертифицирована ни одна
из перебираемых криптосистем.
\end{remark}
\begin{theorem}
Построенная криптосистема $G$ --- полная в классе $\frac 23 - $PKCS.
\end{theorem}
\begin{definition} \emph{Возведение криптосистемы в степень.}
Для криптосистемы $H$ определим $H^k=(e^k, d^k)$, где 
$$e^k(m,r) = (e(m,r_1), e(m,r_2),  \ldots , e(m,r_k)),$$
$$d^k = \textrm{maj}_i \; \{d(e(m,r_i))\}.$$
\end{definition}
\begin{lemma}\label{lem:Hk}
$H \in \frac 23 - $PKCS $\Rightarrow$
\begin{itemize}
\item[1.] $H^k \in (1- e^{- k \cdot \mathrm{const}}) - $PKCS.
\item[2.] $H^k\to H$
(точнее, существует такое оракульное сведение $R$, что если некий "<соперник">  $A$ ломает
$H^k$ с вероятностью $\frac 12 + \frac 1{p(n)}$, то $R^A$ ломает $H$ 
с вероятностью $\frac 12 + \frac 1{p(n) \cdot k}$).
%В частности, это 
%означает, что, если $k$ --- некоторая полиномиальная функция от $n$, 
%то из ненадежности системы $H_k$ следует ненадежность изначальной 
%системы $H$.
\end{itemize}
\end{lemma}

\begin{proof} \par
1. 
Пусть $X_i$ --- случайная величина, соответствующая факту $d(e(m,r_i)) = 
m$.
%Вычислим для каждого $i$ раз значение $d(M_i)$, где $M_i = e(m,r_i), i=1 \dots k$. Далее, 
Применяя
неравенство Чернова, получим 
$$\Pr\left\{\sum X_i \le k/2\right\} = \Pr\left\{\sum X_i \le 2k/3 -k/6\right\} < e^{- \mathrm{const} \cdot k} .$$

2. Будем строить такое сведение: пусть $R^A$ выбирает случайным образом $i \in \{1 \ldots k\}$ и формирует свой запрос к 
$A$ следующим образом:
$$ M = \underbrace{e(0), e(0), \ldots , e(0)}_{i-1}, c, \underbrace{e(1), \ldots , e(1)}_{k-i} ,$$
где $c$ --- тот код, который мы хотим взломать. Этот вход мы даем 
$R^A$. Следует заметить, что такой вход может не являться корректным, 
так как в определении $H^k$ предполагается, что на вход взломщику 
дается массив из кодов нулей либо единиц. Тем не менее, оценим 
вероятность успеха $R^A$. 
{\scriptsize
$$ \Pr \{\mbox{успеха } R^A \} = \frac 12 \Pr\{\mbox{успеха}\; | \; c = e(0)\} + \frac 12 \Pr\{\mbox{успеха}\; | \; c = e(1)\} = $$
$$ 
\frac 12 ( \frac 1k \Pr\{ R^A \mbox{ выдает }  0 \; | M = e(0) \ldots \ e(0)  
\} + \frac 1k \Pr\{ R^A \mbox{ выдает }  0 \; | M = e(0) \ldots \ e(0) e(1)  \} + 
\ldots  
$$
$$
 \ldots + \frac 1k \Pr\{ R^A \mbox{ выдает }  1 \; | M = e(1) \ldots \ e(1)  
\} + \frac 1k \Pr\{ R^A \mbox{ выдает }  1 \; | M = e(0) \ldots \ e(0) e(1)  \} + 
\ldots ) = 
$$
$$\frac 12\left(1-\frac 1k\right) + \frac 1{2k}(\Pr\{ R^A \mbox{ выдает }  0 \; | M = e(0) \ldots \ e(0)   \} + \Pr\{ R^A \mbox{ выдает }  1 \; | M = e(1) \ldots \ e(1)   \}) \ge$$
$$\frac 12 \left( 1 - \frac 1k \right) + \frac 1k \left(\frac 12 + \frac 1{p(n)} \right) = \frac 12 + \frac 1{p(n) \cdot k}.$$}
\end{proof}
\begin{proof}[Доказательство теоремы.]
Результат леммы дает нам экспоненциально 
малую вероятность ошибки построенной криптосистемы $G$. Даже будучи 
просуммированной $n'$ раз, ошибка остается экспоненциально малой. 
\par Покажем, что достаточно ограничиться криптосистемами, 
использующими время $n^2$. Предположим, что у нас есть более медленная 
криптосистема $G_s$. Сделаем из нее быструю криптосистему $G_f$, 
которая отличается от $G_s$ лишь параметром надежности. 
$$G_f(1^n, \ldots) = G_s(1^{\lfloor n^{1/k} \rfloor}, \ldots)$$
Корректность данной системы не изменилась, а надежность все так же 
оценивается полиномом. \par Докажем полноту $G$: сведем взлом некоторой 
криптосистемы $G^*$ ко взлому $G$. Разумеется, в этом случае $n'$ 
больше, чем номер $G^*$, иначе она просто не будет рассмотрена среди 
составляющих $G$. Согласно лемме~\ref{lem:Hk}, мы сводим взлом $G^*$ к взлому 
${G^*}^k$, а затем\footnote{Это надо уметь доказать формально!}
взлом ${G^*}^k$ --- ко взлому $G$.
\end{proof}

\begin{exercise}
Определим tdpf с ошибкой ($\delta$-tdpf). 
Предлагается построить полное $\delta$-tdpf.
\end{exercise}
\begin{exercise}
До этого у нас "<соперник"> был вероятностный. Пусть теперь он 
будет детерминированным. Предлагается построить криптосистему, 
полную в классе криптосистем с детерминированным "<соперником">. 
\begin{remark}
Решение предполагает построение детерминированного сведения.
\end{remark}
\end{exercise}


%\section {Определения надежности}
%\bigskip
%\fbox{\begin{minipage}{145mm}\emph{\large\bfseries{Этот раздел (он не проверялся лектором) будет перенесён в следующую лекцию
%после уточнения определений.}}\end{minipage}}
%\bigskip
%
%Далее будем рассматривать криптосистемы, которые при раскодировании 
%всегда возвращают правильный ответ. 
%\begin{definition}
%\textbf{Семантическая надежность}  \par %%
%\emph{Неформально.} Чарли не может не только раскодировать строку, 
%но также не можит вычислить никакую полиномиально вычислимую функцию 
%от нашего сообщения. Более того, даже если он что-то знает, это ему 
%не поможет. \par %%
%\emph{Формально.} Криптосистема начинается \emph{семантически 
%надежной}, если 
%$$ 
%\forall h \;\; \forall f \;\; \forall C \;\; \forall p \;\; \exists 
%\widetilde C \;\; \Pr\{C(e(m,r_e),e,1^n,1^{|m|},f(m))=h(m) \} \le 
%$$ 
%$$ 
%\Pr\{\widetilde {C}(e,1^n,1^{|m|},f(m))=h(m) \} + \frac 1{p(n)} \; , 
%$$ 
%где $h$, $f$ - полиномиально вычислимые функции, $C$ и $\widetilde 
%C$ - некоторые "<противники">, работающие полиномиальное время, а $p$ 
%- многочлен. Причем $f(m)$ - это значение некоторой функции, 
%которое, теоретически, должно добавлять нам знания о кодируемом 
%сообщении.
%\end{definition}
%\begin{definition}
%Криптосистема называется \emph{неразличимой}, если для любый 
%сообщений $m_0$, $m_1$, для любого "<противника"> \; $C$, работающего 
%полиномиальное время, а также для любого многочлена $p$
%$$ \Pr \{C(e(m_i,r_e),e,1^n,m_0,m_1)=i \} < \frac 1{p(n)} + \frac 12 , \;\; i \in \{0,1\}$$
%\end{definition}
%\begin{remark}
%Эти определения эквивалентны, когда "<противниками"> являются булевы 
%схемы.
%\end{remark}
\end{document}
